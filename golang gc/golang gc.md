**Go (Golang) GC 核心总结笔记**

**一、 核心概念与目标**

1.  **自动内存管理：** Go 是自带垃圾回收（GC）的语言，开发者无需手动 `malloc/free` 或 `new/delete`。
2.  **主要目标：**
    *   **低延迟（Low Latency）：** 最重要的目标。GC 导致的程序暂停时间（Stop-The-World, STW）要尽可能短，力求达到**亚毫秒级**，以保证高并发和实时性应用的性能。
    *   **并发（Concurrency）：** GC 的大部分工作（标记、清扫）与用户 Goroutine 并发执行。
    *   **效率（Efficiency）：** 合理的 CPU 和内存资源消耗。

**二、 核心算法：并发三色标记清扫法 (Concurrent Tri-color Mark-and-Sweep)**

1.  **基本原理：** 可达性分析。从根（Roots：全局变量、Goroutine 栈等）出发，遍历所有可达对象，不可达对象即为垃圾。
2.  **三色标记：**
    *   **白色 (White):** 初始状态，或标记结束后仍为白色的对象，是潜在垃圾。
    *   **灰色 (Gray):** 已标记存活，但其引用的对象尚未扫描完。灰色对象在待处理队列中。
    *   **黑色 (Black):** 已标记存活，且其引用的所有对象都已被扫描（变灰或变黑）。
3.  **GC 周期阶段：**
    *   **(STW) 标记准备 (Mark Setup):** 短暂暂停。**开启写屏障**，准备根对象扫描。
    *   **(Concurrent) 标记 (Marking):** 并发执行。GC 工作协程从根开始遍历对象图，使用三色标记。用户 Goroutine 同时运行。**写屏障在此阶段生效**，追踪指针修改。
    *   **(STW) 标记终止 (Mark Termination):** 短暂暂停。**关闭写屏障**，完成剩余标记工作（处理写屏障日志等），确保所有存活对象标记完成。**混合写屏障极大地缩短了此阶段（无需栈重扫）**。
    *   **(Concurrent) 清扫 (Sweeping):** 并发执行。回收所有白色对象的内存。用户 Goroutine 在分配时可能协助清扫。

**三、 关键机制：写屏障 (Write Barrier)**

1.  **目的：** 在**并发标记**阶段，解决用户 Goroutine 修改指针可能导致 GC 错误回收存活对象的问题（维护三色不变性：不允许黑色指向白色而无灰色路径）。
2.  **原理：**
    *   **编译器注入：** 编译器在**指针写入**操作前插入屏障代码（通常是条件检查+函数调用）。
    *   **运行时实现：** Runtime 提供屏障函数。
    *   **条件执行：** 屏障逻辑只在**并发标记阶段**通过快速的全局标志检查后才激活，平时开销极小。
3.  **混合写屏障 (Hybrid Write Barrier - Go 1.8+):**
    *   **机制：** 同时处理**堆指针写入**和**栈指针写入**。当写入指针 `ptr` 指向白色对象时，**总是将该白色对象标记为灰色**。
    *   **优点：** **消除了标记终止 STW 阶段的栈重扫**，因为栈上指针的并发修改不会丢失对象。显著降低了 STW 时间，使其稳定在亚毫秒级。
    *   **性能：** 虽然覆盖了栈写入，但因快速路径检查和分散开销的设计，相比其消除的 STW 暂停，整体性能收益巨大。

**四、 Stop-The-World (STW)**

1.  **何时发生：** 标记准备（Mark Setup）和标记终止（Mark Termination）两个短暂阶段。
2.  **做什么：**
    *   暂停所有 Goroutine（在安全点）。
    *   **Mark Setup:** 开启写屏障，准备根扫描。
    *   **Mark Termination:** 关闭写屏障，完成最终标记一致性工作。
3.  **为何短：**
    *   主要耗时的标记和清扫工作是并发的。
    *   STW 只做必要的同步、状态切换和少量收尾工作。
    *   混合写屏障消除了耗时的栈重扫。

**五、 栈 (Stack) vs. 堆 (Heap)**

1.  **栈：**
    *   每个 Goroutine 独立。
    *   存储函数调用帧、局部变量。
    *   分配/释放极快（移动指针）。
    *   生命周期确定，无需 GC 管理。
    *   **逃逸分析 (Escape Analysis):** 编译器决定变量分配在栈还是堆。尽可能栈分配以提高性能、减少 GC 压力。
2.  **堆：**
    *   所有 Goroutine 共享。
    *   存储动态分配、生命周期不确定、可能共享的对象。
    *   分配/释放由 GC 管理，相对较慢。
    *   是 GC 的主要工作区域。

**六、 优化与注意事项 (`noscan`, `GOGC`, `pprof`)**

1.  **`noscan` Spans:** 内存分配器将不包含指针的对象（如 `[]byte`）分配在特殊 span 中，GC 会跳过扫描这些 span，提升效率。
2.  **`GOGC` 环境变量:** 控制 GC 触发频率。默认 100，表示新分配内存达到上次 GC 后存活内存的 100% 时触发。调大减少 GC 频率但增加内存占用，反之亦然。谨慎调整。
3.  **`pprof` 工具:** 分析内存分配 (`allocs`, `heap`) 和 GC 性能的关键工具。找出内存热点、优化分配。
4.  **减少分配:**
    *   使用 `sync.Pool` 复用对象。
    *   优化数据结构和算法，避免不必要的临时对象和拷贝（如用 `strings.Builder`）。
5.  **注意逻辑内存泄漏：** 全局变量、未清理的 Map/长生命周期对象等持有的引用，会导致 GC 无法回收，即使业务上不再需要。

**七、 面试可能问到的问题**

*   请简述 Go GC 的工作原理。
*   Go GC 的主要目标是什么？与其他语言 GC 有何不同？
*   什么是三色标记法？白、灰、黑代表什么？
*   Go GC 的周期包含哪些阶段？哪些是并发的，哪些是 STW？
*   STW 主要做什么？为什么 Go 的 STW 很短？
*   什么是写屏障？为什么需要它？
*   解释一下混合写屏障的机制和优势。
*   混合写屏障如何处理栈指针，为什么没有显著影响性能？
*   Go 的栈和堆有什么区别？逃逸分析是什么？
*   如何分析和优化 Go 程序的 GC 性能？（`pprof`, `GOGC`, `sync.Pool`）
*   遇到过 GC 相关的问题吗？如何排查的？

**核心记忆点：** Go GC 是**并发、基于三色标记清扫、目标低延迟**的垃圾回收器。**混合写屏障**是其实现亚毫秒级 STW 的关键技术。理解**写屏障原理、STW 阶段工作、栈堆区别与逃逸分析**非常重要。**`pprof`** 是性能分析利器。