****# Golang GMP 原理

**原创 小徐先生1212 小徐先生的编程世界**  
**2023年01月14日 08:31 北京**

## 1. 概念梳理

### 1.1 线程

通常语义中的线程，指的是内核级线程，核心点如下：

1. **最小调度单元**：线程是操作系统管理的最小调度单位，负责执行程序中的指令。
2. **内核管理**：线程的创建、销毁和调度由操作系统内核完成，涉及用户态与内核态之间的切换，开销较大。
3. **并行执行**：线程可以在多核CPU上并行运行，充分利用多核资源，提高程序执行效率。

### 1.2 协程

![协程示意图](path_to_image)

协程，又称为用户级线程，核心点如下：

1. **映射关系**：协程与线程的映射关系为 M：1，即多个协程映射到一个内核线程上。
2. **用户态管理**：协程的创建、销毁和调度在用户态完成，对操作系统内核透明，资源开销更小。
3. **单线程执行**：多个协程依附于同一个内核线程，无法在多核上并行执行。如果一个协程阻塞，所有依附于该线程的协程都会被阻塞，影响整体执行。

### 1.3 Goroutine

![Goroutine示意图](path_to_image)

Goroutine，经 Golang 优化后的特殊“协程”，核心点如下：

1. **映射关系**：Goroutine 与线程的映射关系为 M：N，即多个 Goroutine 映射到多个线程上。
2. **高效调度**：Goroutine 的创建、销毁和调度在用户态完成，对内核透明，资源开销极低，能够在程序中轻松创建成千上万的 Goroutine。
3. **并行执行**：通过多个线程（M）和调度器（P）的配合，Goroutine 可以在多核 CPU 上并行执行，充分利用多核资源。
4. **动态栈**：Goroutine 的栈空间可以根据需要动态扩展和收缩，节省内存资源。
5. **灵活调度**：通过调度器的协调，实现 Goroutine 与线程间的动态绑定和灵活调度，优化资源利用和执行效率。

### 1.4 对比

三个模型的各项能力对比如下：

| 模型       | 弱依赖内核 | 可并行 | 可应对阻塞 | 栈可动态扩缩 |
|------------|------------|--------|------------|--------------|
| 线程       | ❎         | ✅     | ✅         | ❎           |
| 协程       | ✅         | ❎     | ❎         | ❎           |
| Goroutine | ✅         | ✅     | ✅         | ✅           |

综上，Goroutine 可说是博采众长之物。

实际上，“灵活调度” 一词概括得过于简要，Golang 在调度 Goroutine 时，针对“如何减少加锁行为”、“如何避免资源不均”等问题都给出了精彩的解决方案，这一切都得益于经典的 **GMP** 模型，而这些，就留待第 2 节展开介绍。

## 2. GMP 模型

GMP = Goroutine + Machine + Processor （+ 一套有机组合的机制），下面先单独拆出每个组件进行介绍，最后再总览全局，对 GMP 进行总述。

### 2.1 G（Goroutine）

1. **定义**：G 是 Golang 中对 Goroutine 的抽象，代表一个独立执行的协程。
2. **属性**：
   - **运行栈**：每个 G 有自己的栈空间，用于存储函数调用和局部变量。
   - **状态**：G 有多种状态，如可运行、正在运行、等待、死亡等。
   - **任务函数**：G 执行的具体任务，由用户通过 `go func` 定义。
3. **绑定关系**：G 需要绑定到 P（Processor）上才能被执行。

### 2.2 P（Processor）

1. **定义**：P 是 Golang 中的调度器，负责管理和调度 G 的执行。
2. **属性**：
   - **本地队列**：每个 P 有自己的本地 G 队列，存储待执行的 G。
   - **调度计数**：记录调度次数，用于负载均衡。
3. **角色**：
   - **调度**：P 将 G 分配给 M（Machine）执行。
   - **工作窃取**：当本地队列空闲时，P 可以从其他 P 的本地队列窃取 G，保持负载均衡。
4. **数量**：P 的数量由 `GOMAXPROCS` 设置，通常与 CPU 核数相匹配。

### 2.3 M（Machine）

1. **定义**：M 是 Golang 中对操作系统级线程的抽象。
2. **属性**：
   - **执行栈**：M 有自己的执行栈，用于执行系统调用等。
   - **绑定 P**：M 可以绑定到不同的 P 上，动态执行不同的 G。
3. **角色**：
   - **执行实体**：M 是实际执行 G 的实体，通过 P 调度 G 的执行。
   - **动态绑定**：M 可以在不同的 P 之间切换，确保资源的高效利用。

### 2.4 GMP 宏观模型

![GMP宏观模型](path_to_image)

**GMP 宏观模型**如下图所示：

1. **M 是线程的抽象**；**G 是 Goroutine**；**P 是承上启下的调度器**。
2. **M 调度 G 前，需要与 P 绑定**。
3. **全局有多个 M 和多个 P**，但同时并行的 G 的最大数量等于 P 的数量。
4. **G 的存放队列有三类**：P 的本地队列；全局队列；和等待队列（用于 I/O 阻塞等就绪态的 Goroutine）。
5. **M 调度 G 时，优先取 P 本地队列**，其次取全局队列，最后取等待队列；这样的好处是，取本地队列时，可以接近于无锁化，减少全局锁竞争。
6. **为防止不同 P 的闲忙差异过大，设立工作窃取机制**，本地队列为空的 P 可以尝试从其他 P 的本地队列偷取一半的 G 补充到自身队列。

文字性总结难免有些过于含糊和空洞，对一些细节的描述总是不够精确的。下面照旧开启源码走读流程，从代码中寻求理论证明和细节补充。

## 3. 核心数据结构

GMP 数据结构定义在 `runtime/runtime2.go` 文件中，由于各个类的成员属性较多，这里只摘取核心字段进行介绍。

### 3.1 G（Goroutine）

- **属性**：
  - **m**：指向当前执行该 G 的 M。
  - **sched**：保存 G 的调度相关信息，如栈指针、程序计数器等。
- **生命周期状态**：
  - **_Gidle**：协程开始创建时的状态，尚未初始化完成。
  - **_Grunnable**：协程在待执行队列中，等待被执行。
  - **_Grunning**：协程正在执行，同一时刻一个 P 中只有一个 G 处于此状态。
  - **_Gsyscall**：协程正在执行系统调用。
  - **_Gwaiting**：协程处于挂起态，需要等待被唤醒，如 GC、channel 通信或者锁操作。
  - **_Gdead**：协程刚初始化完成或者已经被销毁，会处于此状态。
  - **_Gcopystack**：协程正在栈扩容流程中。
  - **_Gpreempted**：协程被抢占后的状态。

### 3.2 M（Machine）

- **属性**：
  - **g0**：一种特殊的调度协程，不用于执行用户函数，负责执行 G 之间的切换调度。与 M 的关系为一对一。
  - **tls**：线程本地存储，存储内容只对当前线程可见。`tls[0]` 存储的是当前运行的 G，因此线程可以通过 G 找到当前的 M、P、g0 等信息。

### 3.3 P（Processor）

- **属性**：
  - **runq**：本地 Goroutine 队列，最大长度为 256。
  - **runqhead**：队列头部索引。
  - **runqtail**：队列尾部索引。
  - **runnext**：下一个可执行的 Goroutine，优化调度效率。

### 3.4 schedt（全局调度器）

- **属性**：
  - **lock**：一把操作全局队列时使用的锁。
  - **runq**：全局 Goroutine 队列。
  - **runqsize**：全局 Goroutine 队列的容量。

## 4. 调度流程

### 4.1 两种 G 的转换

如前所述，Goroutine 的类型可分为两类：

1. **g0**：负责调度普通 G 的特殊调度协程，与 M 的关系为一对一。
2. **普通 G**：负责执行用户函数的 Goroutine。

M 通过 P 调度执行的 Goroutine 永远在普通 G 和 g0 之间进行切换。当 g0 找到可执行的 G 时，会调用执行方法，将执行权交给 G；当 G 需要主动让渡或被动调度时，会触发调度方法，将执行权重新回到 g0 手中。

### 4.2 调度类型

调度类型是广义上的“调度”，指的是调度器 P 实现从执行一个 G 切换到另一个 G 的过程。主要分为以下几种：

1. **主动调度**：
   - 用户主动让渡执行权，通过调用 `runtime.Gosched()`。
   - 当前 G 会将执行权让渡，进入待执行队列，等待下次调度。

2. **被动调度**：
   - 因为某些操作（如 channel 操作、互斥锁操作）导致 G 阻塞，进入等待状态，直到条件满足被唤醒。
   - 进入阻塞态时，G 被添加到相应的等待队列中，调度器会选择其他 G 执行。

3. **正常调度**：
   - G 执行任务完成后，状态变为死亡，调度器会选择下一个可执行的 G 进行执行。

4. **抢占调度**：
   - 当 G 执行系统调用超过指定时长，且全局 P 资源紧张时，调度器会中断 G 的执行，重新分配资源给其他 G。
   - 由一个全局监控协程（monitor G）负责发起抢占调度，确保系统的响应性和公平性。

### 4.3 宏观调度流程

宏观调度流程如下：

1. **g0 调度 G**：
   - g0 执行 `schedule()` 函数，寻找下一个可执行的 G。
   
2. **执行 G**：
   - g0 调用 `execute()` 方法，更新当前 G、P 的状态信息，并开始执行 G。
   
3. **G 的执行与切换**：
   - G 执行过程中可能会主动让渡（如调用 `runtime.Gosched()`）或被动调度（如等待 I/O），触发调度器将执行权重新回到 g0。
   
4. **开启新一轮调度**：
   - g0 再次执行 `schedule()` 函数，寻找下一个可执行的 G，循环往复。

### 4.4 schedule

调度流程的主干方法是 `schedule` 函数，此时的执行权位于 g0 手中：

1. **寻找可执行的 G**：
   - 调用 `findRunnable()` 函数，找到下一个可执行的 G。
   
2. **执行 G**：
   - 调用 `execute(gp, inheritTime)` 方法，开始执行找到的 G。

### 4.5 findRunnable

`findRunnable` 是调度流程中的核心步骤，负责为 M 寻找到下一个执行的 G：

1. **周期性从全局队列获取 G**：
   - P 每执行一定次数（如 61 次），会尝试从全局队列获取 G，补充本地队列。

2. **从本地队列获取 G**：
   - 首先尝试从 P 的本地队列获取 G，确保本地队列的高效利用。

3. **从全局队列获取 G**：
   - 如果本地队列没有可执行的 G，会尝试从全局队列获取。

4. **处理网络协程**：
   - 如果全局队列和本地队列都没有 G，会尝试获取准备就绪的网络协程。

5. **工作窃取**：
   - 如果本地队列和全局队列都没有 G，P 会尝试从其他 P 的本地队列中窃取 G，确保负载均衡。

### 4.6 execute

当 g0 为 M 寻找到可执行的 G 之后，接下来就开始执行 G：

1. **更新状态信息**：
   - 将当前 G 的状态从可运行变为运行中，建立 G 与 M 之间的绑定关系。
   
2. **更新调度计数**：
   - 增加 P 的调度计数，决定是否需要从全局队列获取更多 G。
   
3. **执行 G**：
   - 调用 `gogo()` 方法，将执行权交给 G，开始执行其任务。

### 4.7 gosched_m

当 G 执行主动让渡时，会调用 `mcall` 方法将执行权归还给 g0，并由 g0 调用 `gosched_m` 方法：

1. **状态转换**：
   - 将当前 G 的状态从运行中切换为待执行状态（_Grunnable）。
   
2. **解绑 G 和 M**：
   - 解除当前 G 与 M 之间的绑定关系，释放资源。
   
3. **添加到全局队列**：
   - 将 G 添加到全局队列，等待被调度执行。
   
4. **开启新一轮调度**：
   - 调用 `schedule()` 方法，启动新的调度流程。

### 4.8 park_m 与 ready

当 G 需要被动调度时，会调用 `gopark` 方法将 G 置为阻塞态：

1. **状态转换**：
   - 将当前 G 的状态从运行中改为等待状态（_Gwaiting）。
   
2. **解绑 G 和 M**：
   - 解除当前 G 与 M 之间的绑定关系，释放资源。
   
3. **执行新一轮调度**：
   - 调用 `schedule()` 方法，启动新的调度流程。

当阻塞的 G 需要被唤醒时，会由其他协程调用 `goready` 方法：

1. **状态转换**：
   - 将 G 的状态从等待态改为可执行态（_Grunnable）。
   
2. **添加到本地队列**：
   - 将 G 添加到唤醒者的 P 的本地队列中，如果队列满了，会将一半的 G 转移到全局队列中，缓解本地队列的压力。

### 4.9 goexit0

当 G 执行完成时，会调用 `goexit0` 方法：

1. **状态转换**：
   - 将 G 的状态置为死亡状态（_Gdead）。
   
2. **解绑 G 和 M**：
   - 解除 G 与 M 之间的绑定关系，释放资源。
   
3. **开启新一轮调度**：
   - 调用 `schedule()` 方法，启动新的调度流程。

### 4.10 retake

抢占调度的执行者是一个全局的监控 Goroutine（monitor G），负责监控所有 P 的执行状况，并在需要时主动发起抢占调度：

1. **遍历所有 P**：
   - 检查每个 P 的执行状态，寻找需要被抢占的目标。
   
2. **条件判断**：
   - 如果 P 执行系统调用超过指定时长，且本地队列有待执行的 G，或当前没有空闲的 P 和 M，则进行抢占调度。
   
3. **状态转换**：
   - 将 P 的状态更新为 idle，准备重新分配资源。
   
4. **绑定新的 M**：
   - 如果需要，为 P 获取一个新的 M，以继续调度执行 G。

### 4.11 reentersyscall 和 exitsyscall

与系统调用相关的调度处理：

1. **进入系统调用（reentersyscall）**：
   - 当 M 需要执行系统调用时，保存当前 G 的执行状态，将 G 的状态设置为系统调用中（_Gsyscall）。
   - 解除 P 和 M 之间的绑定，标记 P 为系统调用状态（_Psyscall）。
   
2. **退出系统调用（exitsyscall）**：
   - 系统调用完成后，尝试重新绑定 P 和 M，恢复 G 的执行状态。
   - 如果旧 P 可用，将 G 重新绑定到 P 上继续执行；否则，将 G 添加到全局队列，等待其他 P 调度执行。
   - 解除 G 与 M 之间的绑定，准备下一轮调度。

## 5. P 和 g0 的任务分工

### 5.1 P（Processor）的职责

- **管理本地队列**：
  - 每个 P 拥有自己的本地 Goroutine 队列，负责存储和管理待执行的 G。
  
- **调度 G**：
  - 从本地队列中选择 G，并将其绑定到可用的 M 上执行。
  
- **工作窃取**：
  - 当本地队列空闲时，P 会尝试从其他 P 的本地队列中窃取一半的 G，保持负载均衡。
  
- **维护调度计数**：
  - 记录调度次数（如 schedtick），决定何时从全局队列获取更多 G。

### 5.2 g0（调度 Goroutine）的职责

- **执行调度逻辑**：
  - g0 是一个特殊的 Goroutine，负责执行调度相关的任务，如选择下一个要执行的 G、处理系统调用等。
  
- **辅助 P 进行调度**：
  - 在某些调度操作中，g0 会与 P 协同工作，调用调度函数来选择和绑定 G 给 M。
  
- **管理 G 的切换**：
  - 当 G 主动让渡或被动调度时，g0 负责将执行权切换到其他 G，保持调度流程的顺畅。
  
- **处理系统调用**：
  - 在 M 执行系统调用时，g0 负责处理阻塞和恢复的调度任务，确保系统调用期间调度器的高效运行。

### 5.3 P 和 g0 的协同工作

- **调度流程**：
  1. **P 选择和绑定 G**：
     - P 从本地队列或全局队列中选择 G，并将其绑定到 M 上执行。
  
  2. **执行 G**：
     - M 开始执行 G，G 在执行过程中可能会主动让渡或因阻塞操作进入等待状态。
  
  3. **G 切换回 g0**：
     - 当 G 需要让渡或被动调度时，会调用调度方法，将执行权重新回到 g0。
  
  4. **g0 执行调度逻辑**：
     - g0 根据当前的调度策略，选择下一个要执行的 G，并将执行权交给 P，继续循环。

- **任务分工**：
  - **P**：负责管理本地队列、选择和绑定 G 到 M 上执行、执行工作窃取。
  - **g0**：负责执行调度逻辑、管理 G 的切换和系统调用处理，辅助 P 完成调度任务。

## 6. 系统调用与调度

### 6.1 进入系统调用（reentersyscall）

当 M 需要执行系统调用时，会进行以下步骤：

1. **保存执行状态**：
   - 保存当前 G 的执行环境，包括栈指针和程序计数器，以便系统调用完成后能恢复执行。
   
2. **状态转换**：
   - 将 G 的状态从运行中（_Grunning）设置为系统调用中（_Gsyscall）。
   
3. **解绑 P 和 M**：
   - 当前 P 与 M 解除绑定，标记 P 为系统调用状态（_Psyscall），表示 P 正在进行系统调用，不可用于调度其他 G。
   
4. **处理调度**：
   - 由于 M 进入系统调用状态，调度器需要重新分配 P 来调度其他 G，确保系统资源的高效利用。

### 6.2 退出系统调用（exitsyscall）

系统调用完成后，M 需要恢复 G 的执行：

1. **尝试快速恢复**：
   - 如果旧 P（oldp）仍然可用，直接将 G 重新绑定回 P，并将 G 的状态改为运行中（_Grunning），继续执行。
   
2. **处理不可用的 P**：
   - 如果旧 P 不可用，则将 G 重新加入全局队列，等待其他 P 调度执行。
   
3. **资源释放**：
   - 解除 G 与 M 的绑定，准备下一次调度，确保 M 可以重新绑定到其他 P，继续执行其他 G。

## 7. 综合总结

通过以上内容，我们对 Golang 的 GMP 调度模型有了全面的了解：

1. **调度器的组成**：
   - **P** 是调度器的核心组件，负责管理本地 Goroutine 队列，并将 Goroutine 分配给 M 执行。
   - **g0** 是辅助调度的特殊 Goroutine，与每个 M 一一对应，负责执行调度相关的任务。

2. **负载均衡的实现**：
   - 通过本地队列优先、全局队列辅助和工作窃取机制，实现 P 之间的负载均衡，确保资源的高效利用。

3. **P 的属性与管理**：
   - **主要属性**包括上下文和本地 Goroutine 队列。
   - **数量**由 `GOMAXPROCS` 决定，通常与 CPU 核数相匹配，并可在运行时动态调整。

4. **全局队列中的 Goroutine**：
   - 当本地队列满溢、高负载或其他特定情况时，Goroutine 会被添加到全局队列，以确保调度的灵活性和负载均衡。

5. **从全局队列获取 Goroutine 的机制**：
   - 基于调度周期和特定触发条件，P 会在适当的时机从全局队列获取 Goroutine，保持调度器的高效运转。

6. **绑定 G 与 M 的驱动者**：
   - **P** 是主要的调度驱动者，负责选择和绑定 G 到 M 上执行。
   - **g0** 则在调度过程中提供辅助支持，执行调度逻辑、管理 G 的切换和系统调用处理。

通过理解这些机制，您可以更深入地掌握 Golang 的并发模型，优化程序的性能和资源利用，充分发挥多核 CPU 的优势。

---
