# 旧版 Go `map` 底层原理（修订版 · Markdown 完整稿）

> 先更正一个时间线：Go 1.24 起内置 `map` 的**默认实现**切换为基于 _Swiss Tables_ 的新架构；但 **1.25 并未“彻底移除”旧实现**，旧实现依然保留在源码中，并可通过 `GOEXPERIMENT=noswissmap` 选择使用（源码文件以 `map_noswiss.go` 等命名，带 `!goexperiment.swissmap` 构建标签）。下篇我们再专讲新版 Swiss Map。本文专注**旧版 `map`**。([Go.dev](https://go.dev/src/internal/runtime/maps/runtime_noswiss.go?utm_source=chatgpt.com "- The Go Programming Language"))

---

## 开场

你可能不知道，Go 语言在 1.24 把 `map` 的默认底层实现改成了 Swiss Map。为了把握对比维度，这期作为上篇，我们从零搞懂**旧的 `map` 实现**；下篇再讲新实现。话不多说，直接开始！

---

## 预备知识：哈希、O(1) 与“回绕”

**哈希函数**：输入元素 → 输出定长散列。不同输入通常得不同输出；偶尔会“撞车”（**哈希冲突**）。

**为何查询平均 O(1)**：对 `key` 做哈希，**映射到数组下标**，再根据数组首地址与元素大小计算出目标地址，由硬件直接读取。

**取模 vs 按位与**：当数组长度是 **2 的幂** 时，`x % 2^N` 等价于 `x & (2^N - 1)`。这在很多底层实现（包括旧 `map`）会直接用**掩码**而不是除法，速度更友好。

> 例：26（二进制 `11010`）对 8 取模等价于 `26 & 7`，结果都是 2。

顺带提一下我们在讲 **GMP 模型**（不是 “PMG”，这里口误已更正）时也说过，“回绕”就是用模/掩码把“大索引”映到环形队列里。Golang 源码中相关地方常写成 `%`，但在 `map` 实现里你能直接看到 **按位与掩码**的用法。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

---

## 旧版 `map` 的核心结构

旧实现的头结构体叫 **`hmap`**（_hash map header_）。它维护了桶数组指针、计数、随机种子等元信息：

- `buckets`：指向**桶（bucket）数组**的指针。
    
- `count`：元素个数。
    
- `hash0`：**每个 `map` 独有的哈希种子**，同样的 `key` 在不同 `map` 里会哈到不同位置，抗预测。
    
- `flags`：写入状态、迭代状态等位标志。写入时会置位，发生并发写入会触发运行时 **fatal**。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))
    

### 桶（`bmap`）的形状

每个桶最多容纳 **8 对 key/value**，并维护一个长度为 8 的 `tophash` 数组（每格 1 字节），通常存**哈希值的高 8 位**作为“门牌号”。桶满了会通过指针挂上**溢出桶（overflow）**形成链。源码注释清楚写着“每桶最多 8 对键值 + 控制字节 + 溢出指针”，`tophash` 的几个取值还保留了空、已迁移等状态。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

> 注意：`bmap` 的源码里**看不到**显式的 `keys/values` 字段——具体布局由编译器按 key/value 的真实类型**在编译期生成**：先是 8 个 key 的连续区域，再是 8 个 value 的连续区域，前面还有 8 个 `tophash` 控制字节，末尾跟一个 overflow 指针。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

---

## 初始化：`make(map[K]V, hint)`

当你写 `make(map[int]string, 20)` 时，运行时会从 `B=0` 试起，选一个**桶个数为 `2^B`** 的大小，使得**平均装载因子**不过阈值。  
旧实现的**负载因子阈值 ≈ 6.5**（即平均每桶不超过约 6.5 个元素），一旦超过就触发扩容策略。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

- 例：`hint=20`
    
    - `B=0 → 1` 桶，平均 20/1=20（太大）
        
    - `B=2 → 4` 桶，平均 20/4=5（≤6.5），接受 → 分配 4 个桶
        

> 如果 `make` **没给容量**，旧实现会**懒分配**：首次插入时再分配第一个桶，避免一上来就拍脑袋分太大或太小。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

---

## 定位：掩码寻桶 + `tophash` 快速比对

### 1）混入哈希种子

插入/查询时，会将 `key` 与 `hmap.hash0` 混合后哈希，得到 64 位散列。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

### 2）**按位与**寻桶

用 `hash & bucketMask(B)` 直接定位桶下标（`bucketMask(B) = 2^B - 1`），这是按位与版的“对 `2^B` 取模”。源码里就是这么写的，不是 `%`。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

### 3）`tophash` 先筛一遍

把哈希的**高 8 位**记作 `top`，顺序扫描桶内 8 个槽位、优先对比 `tophash[i] == top`：

- 不等：**O(1)** 跳过；
    
- 相等：再去比真 `key`；
    
- 如果遇到 `emptyRest`（空到结尾），可**早停**。  
    找不到就沿 `overflow` 链接继续扫。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))
    

> 设计动机：`tophash` 是字节级的**快速预筛**，避免对每个槽位都做长 key 或长哈希的重比对，显著减少指令与内存访问。

---

## 写入与并发安全

写入路径会先把 `flags` 的 **`hashWriting`** 位置 1，结束再清零；如果另一个 Goroutine 同时写，运行时直接 `fatal`，常见报错包含：

- `fatal error: concurrent map read and map write`
    
- `fatal error: concurrent map writes`
    

这是 Go 对“`map` 写入**并发不安全**”的**主动防护**。相关报错字符串与触发点在运行时代码和测试里都能看到。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))

---

## 扩容：阈值触发与“同尺寸扩容”

当**将要超过**负载因子阈值（≈6.5）**或**溢出桶太多，就会触发 `hashGrow`：

- **增量扩容**：`B += 1`，桶数翻倍；
    
- **同尺寸扩容**：若主要问题是**溢出桶太多**而不是负载超阈，就**不增大**桶数，仅做“横向扩容”以回收溢出链（`sameSizeGrow`），减少未来查询的链长。  
    搬迁是**渐进式**的：访问相关桶时顺带搬，避免一次性停顿。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))
    

---

## 写入流程小结（以插入 `key=13, value="alpha"` 为例）

1. 将 `13` 与 `hash0` 混合哈希得 `hash`。
    
2. 若首次写入且尚未分配桶，则**懒分配**首个桶。
    
3. 用 `hash & (2^B-1)` 定位桶下标，取到目标桶指针。
    
4. 计算 `top = tophash(hash)`，顺序扫描 8 个槽：
    
    - 命中 `tophash` + `key` 相等 → 覆盖旧值；
        
    - 找到空槽 → 写入 `top/key/value`；
        
    - 桶满 → 挂/走 `overflow`。
        
5. 写前检查是否需要扩容（负载/溢出判断），必要时触发 `hashGrow`。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))
    

---

## 为什么不是“一元素一格”的拉链法？

如果用“单元素 + 指针链表”解决冲突，每次冲突都要**单独分配**内存、链指针、可能导致**缓存不友好**。旧 `map` 选择一次申请**一个桶（8 槽）**，把常见冲突都消化在桶内，

- **空间利用更高**（一次申请用多次），
    
- **局部性更好**（tophash + keys/values 连续），
    
- **链表退化少**（只有超载时才走 `overflow`）。
    

---

## 复杂度与退化

- **平均**：`O(1)`（常数因子与冲突密度、`tophash` 命中率、链长有关）。
    
- **最坏**：当哈希退化或溢出链极长，可能接近 `O(n)`。  
    旧实现通过**负载因子阈值**与**同尺寸扩容**抑制链条增长，尽量让平均性能稳定。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))
    

---

## 小结 & 预告

这一篇你已经拿下旧 `map` 的关键点：

- 每桶 8 槽位 + `tophash` 预筛 + 溢出桶链；
    
- `hash0`（每 `map` 独立种子）抗预测；
    
- 掩码寻桶：`hash & (2^B-1)`；
    
- 负载因子阈值 ≈ 6.5，触发扩容/同尺寸扩容；
    
- 写入并发不安全，运行时主动 `fatal`。
    

下篇我们来拆新版 **Swiss Map**：它如何用控制字节、分层目录与新搬迁策略在多数场景显著提速，又为何在“冷缓存+超大 `map`”里暴露了瓶颈，以及 Go 1.25 的修复方向。

---

### 参考（要点出处）

- Go 1.24 将内置 `map` 切换为 Swiss Tables 实现（官方博客/发行说明）；1.25 仍保留旧实现，可通过 `GOEXPERIMENT=noswissmap` 选择。
    
- 旧实现源码：每桶最多 8 对键值、`tophash` 是哈希高位控制字节、溢出桶链、`hash & bucketMask(B)` 寻址、负载因子与扩容逻辑、`hash0`、并发写入 `fatal` 等。([Go.dev](https://go.dev/src/runtime/map_noswiss.go "- The Go Programming Language"))
    
- 并发写入典型报错字符串验证。
    

---

> 如果你愿意，我也可以把这份稿子**生成一版对照大纲**或**加上示意图**（ASCII/白板风格），方便你在视频里直接用作旁白与讲稿。# 旧版 Go `map`：桶内存布局、`tophash`、修改/删除与可比较性（修订后的完整稿 · Markdown）

> **前置假设**：以下讨论默认 **64 位平台**（指针 8B，`int` 8B，字符串头 16B：指针 8B + 长度 8B）。在 32 位平台相应尺寸会减半。为便于讲解，仍以“右侧内存布局图”为视觉参照。

---

## 桶的内存布局：从“心智图”到真实布局

右侧的内存布局图，可能更接近你在 C 语言里习惯的样子：**从上到下顺序排列**。以一个桶（`bucket`/`bmap`）为例，它的概念布局如下：

- **`tophash[8]`（8B）**：每个槽位 1B，保存哈希的“门牌号”。
    
- **`keys[8]`**：8 个 key 连续排布。
    
- **`values[8]`**：8 个 value 连续排布。
    
- **`overflow` 指针（8B）**：指向溢出桶，位于桶**尾部**。
    

> ⚠️ **现实中的对齐（padding）**  
> 真正的内存布局会插入**对齐填充**：
> 
> - `keys` 的起点必须满足 **key 类型的对齐要求**；
>     
> - `values` 的起点必须满足 **value 类型的对齐要求**；
>     
> - `overflow` 之前也可能有填充。  
>     运行时不会“手搓”偏移，而是用**编译器预计算**好的 `dataOffset` 作为数据区起点；在此基础上再推导 `keysBase`、`valuesBase` 等位置。
>     

一个更接近真实的“概念示意”如下（并非精确字节图）：

```
bucketBase:
┌──────────────────────────────┐
│ tophash[8]       (8B)        │
├─────────── padding ──────────┤ ← 为满足 key 对齐
│ keys[8]          (8*keySize) │
├─────────── padding ──────────┤ ← 为满足 value 对齐
│ values[8]        (8*valSize) │
├──────────────────────────────┤
│ overflow pointer  (8B)       │
└──────────────────────────────┘
```

---

## 地址计算：用“对齐后的起点”套同一套公式

把“挨着 8B 的 `tophash` 之后就是 `keys`”换成更严谨的表达：

- `keysBase = bucketBase + dataOffset`（**由编译器预计算**；已考虑对齐）
    
- `valuesBase = keysBase + bucketCnt * keySize`（同样满足对齐）
    
- 第 _i_ 个 **key** 的地址：`keysBase + i * keySize`
    
- 第 _i_ 个 **value** 的地址：`valuesBase + i * valueSize`
    
- `overflow` 在桶尾（可能有对齐填充后再放指针）
    

> **例**（64 位，`key=int`=8B，`value=string` 头=16B，真实字符串内容存堆上）：
> 
> - `keys` 区总大小：`8 * 8B = 64B`
>     
> - `values` 区总大小：`8 * 16B = 128B`
>     
> - 第 1 槽（下标 0）的 key 地址：`keysBase + 0*8B`
>     
> - 第 1 槽的 value 地址：`valuesBase + 0*16B`
>     

扫描到 `tophash` 命中某个槽位 _i_ 后，**同下标**的 key/value 就用上述公式直接定位即可；第 2 槽位就是把 `i` 改为 1，以此类推。**公式不变，但一定以“对齐后的起点”为准**。

---

## 为什么只存“高 8 位”的 `tophash`

`tophash` 取哈希结果的**高 8 位**作为 1 字节门牌号，目的是**预筛**：

- 先比 1B 的 `tophash`，不等则 **O(1)** 跳过；
    
- 相等再比“真 key”。  
    这能显著减少长 key / 全哈希反复比对的次数。
    

**状态值与普通条目**

- **`0..4` 为保留状态**（如 `emptyRest=0`、`emptyOne=1`、迁移标记等）；
    
- **普通条目**的 `tophash` ∈ **[5..255]**；
    
- 若计算出的高 8 位 `<5`，会被**抬到 5**，保证与状态值区间分离。
    

**缓存友好**  
`tophash[8]` 仅 8B，很容易一次性装进 L1 cache；线性扫 8 个槽位几乎是“白给”的。

---

## 连续 key、低位碰撞与随机种子（`hash0`）

桶寻址用哈希的**低 `B` 位**（`bucket = hash & (2^B-1)`）。如果哈希低位扩散不好，**连续 key（0,1,2, ...）** 可能低位相同而“扎堆同一桶”，造成快速溢出、链条拉长，查询退化。

Go 的做法是：**每个 map 都有独立的随机种子 `hash0`**，与 `key` 一起输入哈希，配合位扩散策略，显著降低“低位被人构造”的可行性。理解这个点，有助于理解**为什么需要 per-map seed**：它让“按低位构造冲突”的成本变高、可预测性变差。

---

## 修改操作：定位一致，命中即覆盖

“修改”和“插入”共用同一套定位流程：

1. `key` 与 `hash0` 混合哈希；
    
2. 用 **掩码** `hash & (2^B-1)` 选中目标桶；
    
3. 从左到右扫描 8 个槽位：先比 `tophash`，命中再比 key；
    
4. 命中目标槽后，**覆盖写回 value 槽**（如将 key=13 的 value 改为 `"ALPHA"`：覆盖该槽位里的**字符串头**：指针与长度；**实际字符串数据仍在堆上**）。
    

---

## 删除操作：清键、清值、设状态、减计数

`delete(m, k)` 的核心动作不只是“把 value 置空”，而是**四步**：

1. **清零 value 槽**
    
    - 若含指针字段，逐字段置 `nil`；
        
    - 若是 `string`：置空头（指针 `nil`、长度 0）；
        
    - 若是结构体：把结构体中的**所有指针字段**都置 `nil`，确保不再持有外部对象的引用（便于 GC 回收）。
        
2. **清零 key 槽**
    
    - 同样按类型置零/置 `nil`。
        
3. **设置 `tophash` 为状态值**
    
    - 一般置为 **`emptyOne`**；
        
    - 如果该槽位**之后都无有效元素**，可置为 **`emptyRest`**，让后续查找能**早停**（遇到 `emptyRest` 即可断定“后面都空了”）。
        
4. **`hmap.count--`**
    
    - 维护元素总数的正确性。
        

这样既能让 GC 看到指针已断开（无人持有即可回收），又让后续插入可以复用槽位，同时提升查找的“早停”效率。

---

## 可比较类型与不可比较类型：哪些 key 可以用？

你可能听说过：`map` 的 **key 必须是可比较类型**。直观如 `int`、`bool`、`uintptr` 都可比较。含指针的类型里，判断标准是“**语言层面定义了等值语义**”。

**可比较（可作 key）的常见类型**

- **指针类型**：比较“是否指向同一地址”。
    
- **`string`**：比较内容；实现可先比长度再比字节序列（长度不同直接不等）。
    
- **接口（`interface`）**：相等当且仅当“动态类型一致且动态值相等”（可理解为“方法表相同 + `data` 相等”）。
    
- **`chan`**：只有在**指向同一个底层通道对象**时才相等。
    
- 以及所有内置可比较的基本类型与由它们组成、且字段本身都可比较的**结构体 / 数组**。
    

**不可比较（不能作 key）的常见类型**

- **切片（`slice`）**：切片头（指针、`len`、`cap`）无法唯一代表“内容相等”，语义复杂且高开销，故禁止。
    
- **`map` 本身**：即便逻辑内容一致，物理布局、插入顺序、哈希分布都可能不同，判断相等需要遍历比对，成本过高。
    
- **函数（`func`）**：语义难定义；两个函数即便“做同样的事”，其代码地址也可能不同，语言层面直接禁止比较。
    

---

## `tophash` 状态在删除后的作用

回到 `tophash` 的状态值：

- **`emptyOne`**：该槽位为空，但**后续不保证为空**；
    
- **`emptyRest`**：该槽位为空，且**其后都为空**（本桶内可直接早停）。  
    删除时将 `tophash` 置为合适的状态值，有两个好处：
    

1. **查找加速**：遇到 `emptyRest` 立即停止；
    
2. **插入复用**：`emptyOne` 槽位可直接被复用，无需增链。
    

---

## 负载因子与扩容：不仅是“≥ 6.5 就翻倍”

你可以继续保留“**负载因子 ≈ 6.5/桶**”这个经验阈值，但要把触发条件说全：旧实现有 **两条**扩容路径——

1. **翻倍扩容（`B++`）**：当平均装载接近阈值，**桶数 ×2**，降低冲突密度。
    
2. **同尺寸扩容（`sameSizeGrow`）**：当主要问题是**溢出桶过多**而非负载过高时，不增桶只做“横向清理”，把元素重新分布以**回收溢出链**、缩短查找链长。
    

两条路径都采用**渐进式搬迁**：访问相关桶时顺带搬，避免一次性长停顿。

> **一句话总结**：扩容是“看两件事”——**装载是否过高**、**溢出是否过多**；对应“翻倍”与“同尺寸”两种手段。

---

## 一个完整的“修改/删除”小剧场（延续示例）

以 key=13：

1. **定位**：`hash = H(13, hash0)`，`bucket = hash & (2^B-1)` → 命中第一个桶。
    
2. **扫描**：线扫 `tophash[0..7]`，遇到与 `top=high8(hash)` 相等的槽位，进一步比 key。
    
3. **修改**：命中第 2 槽（举例），直接覆盖该槽位的 **value 头部**（字符串：指针/长度）。
    
4. **删除**：若执行 `delete(m, 13)`：
    
    - 清零 value 槽（指针字段置 `nil`，字符串头清零……）；
        
    - 清零 key 槽；
        
    - 设 `tophash` 为 `emptyOne` 或（若后续全空）`emptyRest`；
        
    - `count--`；
        
    - 槽位可复用；相关对象若无其它引用，后续 GC 可回收。
        

---

## 小结

- **桶布局**：`tophash`（8B）+ `keys` 区 + `values` 区 + `overflow`，中间有**对齐填充**；偏移由**编译器预计算**。
    
- **地址公式**：以 `dataOffset` 为起点，`keysBase`/`valuesBase` 再加 `i * elemSize`；**先对齐后计算**。
    
- **`tophash`**：1B 预筛，普通条目 ∈ `[5..255]`，`0..4` 为状态值；缓存友好。
    
- **随机种子**：`hash0` 混入哈希，显著降低“低位构造冲突”的可行性。
    
- **修改/删除**：命中即覆盖；删除要**清 key、清 value、设状态、减计数**，并利于 GC 与后续复用。
    
- **可比较性**：仅**可比较类型**可作 key；`slice`/`map`/`func` 等不可比较，语言层面禁止。
    
- **扩容**：不仅有“≥6.5/桶就翻倍”，还要看**溢出桶过多**时触发**同尺寸扩容**，并采用**渐进式搬迁**稳定延迟。
    

---

> 如果你需要，我可以把这里的“带对齐的桶布局图”和“地址计算公式”单独出一页讲义/白板图（ASCII 或可打印 PDF），方便你在视频里直接挂图讲解。

# Go `map` 扩容机制与内存管理详解（修订版）

以下是对 Go `map` 扩容机制、内存布局和垃圾回收（GC）优化策略的深入分析与优化表述，保持原有风格和尽量不省略细节。

---

## 扩容方式：翻倍扩容与等量扩容

Go 语言的 `map` 在扩容时有两种常见方式：**翻倍扩容**和**等量扩容**。

### 1. 翻倍扩容

当负载因子超过设定阈值（一般为 6.5）时，`map` 会触发 **翻倍扩容**。在这种情况下，桶数量 `b` 会增加一，使得桶的数量由 `2^b` 扩展到 `2^(b+1)`。这一过程是通过计算新的桶数量来实现的，`b` 的增加意味着原有的桶数量会翻倍。

### 2. 等量扩容

除了翻倍扩容，`map` 还有一种**等量扩容**策略，它并不依赖负载因子的计算，而是通过判断溢出桶（`overflow bucket`）的数量来触发扩容。如果溢出桶的数量等于原生桶的数量，那么会执行等量扩容。在这种情况下，`b` 并不会增加，而是直接分配新的桶来减少溢出桶的压力。

在源码中，扩容时会判断以下两个条件来确定是否触发扩容：

- **`overLoadFactor`**：检查负载因子是否超过了 6.5；
    
- **`tooManyOverflowBuckets`**：检查溢出桶的数量是否等于原生桶的数量。
    

如果任一条件成立，`map` 会调用扩容函数进行扩容。触发扩容后，`buckets` 指针会指向新的桶数组，而原先的桶数组会被移交给 `oldbuckets` 指针，作为旧数据的存储空间。新数组会为新的数据分配空间，并开始处理新的元素。

---

## 细节解读：扩容函数中的操作

### 新桶数量计算

在扩容的第一步，扩容函数会计算一个新的桶数量：

- **翻倍扩容**：将原本的 `b` 增加 1，相当于桶数量由 `2^b` 扩展为 `2^(b+1)`；
    
- **等量扩容**：在溢出桶数量等于原生桶数量时，不增加 `b`，但会分配一个新的桶数组来重新分配现有的元素。
    

### 数据搬迁进度：`nevacuate` 和 `extra` 字段

`nevacuate` 字段记录扩容过程中搬迁的进度。每当一个桶完成搬迁时，这个字段就会增加 1，帮助追踪当前的搬迁进度。

`extra` 字段则用于与 **垃圾回收（GC）** 相关的优化。在扩容期间，溢出桶会被标记为“被占用”，以防止它们在搬迁过程中被错误回收。具体而言，`extra` 字段通过存储溢出桶的指针，确保 GC 不会回收它们。

---

## 垃圾回收（GC）：如何保护溢出桶

### GC 与内存回收

Go 的垃圾回收机制旨在回收不再被活跃引用的内存。GC 会扫描内存中不再被根对象（root object）引用的对象，将其标记为可回收。

- **根对象**是那些在程序中被直接引用的对象。例如，全局变量、`main` 函数中初始化的对象等。
    
- **被占用的内存**，包括被指针引用的内存区域，GC 会将其标记为“被持有”，从而避免误回收。
    

### `extra` 字段与溢出桶的保护

`extra` 字段确保在扩容过程中，**溢出桶不会被误回收**。当 `map` 扩容时，溢出桶的数据可能会继续存储在旧桶数组（`oldbuckets`）中，直到所有数据被迁移到新桶。因此，GC 在执行回收时需要避免回收溢出桶中的数据。

- **优化策略**：`extra` 字段指向溢出桶，并在 GC 扫描时直接标记它们为“被使用”，从而避免这些桶被误回收。
    

---

## `map[int]int` 和 `map[int]string` 的 GC 优化

对于不含指针的 `map`（例如 `map[int]int`），GC 不需要扫描 `keys` 和 `values` 数组，因为它们的内容是直接存储在内存中的，不涉及指针引用。

然而，对于包含指针的 `map`（例如 `map[int]string`），GC 需要扫描 `values` 数组，找到被 `string` 类型指向的实际内存块，标记为“被持有”，从而防止它们被回收。

- **`map[int]int`**：因为 `int` 类型数据不包含指针，GC 不会扫描键值数组，内存直接复用。
    
- **`map[int]string`**：GC 会扫描 `values` 数组，标记被 `string` 类型指向的字符串数据为“被持有”，避免回收。
    

---

## 并发写入和 `map` 并发问题

Go 的 `map` 并不支持并发写入。对于同一个 `map`，如果有多个 goroutine 同时进行写操作，程序会发生**数据竞态**，导致不可预知的行为。

### 并发问题示例

考虑以下并发写入的场景：

```go
map := make(map[string]int)
go func() {
    map["Alex"] = 100
}()
go func() {
    map["Alex"] = 200
}()
```

在这种情况下，由于 GMP 调度的不可控性，两个 goroutine 可能会同时对 `map["Alex"]` 进行赋值。这导致 `map` 中的值无法预测，可能是 100 也可能是 200，取决于 goroutine 的执行顺序。

### 并发读写

Go 的 `map` 允许并发读，但不允许并发写。对于并发读写的场景，Go 运行时并不会直接产生错误，但仍然不安全，可能导致不一致的状态。并发写的场景则会触发运行时错误，具体表现为 panic（`fatal error: concurrent map writes`）。

---

## `map` 内部字段和内存对齐

### 字段对齐与内存布局

Go 的内存布局通过内存对齐来优化读取效率。**内存对齐**是为了确保数据结构的每个字段按照指定的字节边界存储，从而提高 CPU 的内存读取效率。

例如，在 `hmap` 结构体中，字段顺序决定了如何在内存中排列。Go 编译器会对内存进行自动优化，确保各字段按适当的边界对齐，以避免内存读取时的额外开销。

### 内存对齐的实际影响

如果我们更改字段的顺序（如将一个字段从 8 字节类型调整为 4 字节类型），会影响内存对齐和访问速度，进而影响性能。

对于包含多个字段（如 `noverflow` 和哈希种子）的结构体，字段对齐不仅要考虑其类型大小，还要考虑如何最大化内存读取效率，避免跨越多个内存块读取。

---

## 扩容与数据迁移

在扩容期间，`map` 会根据哈希值重新分配数据，并按照以下原则进行数据迁移：

- **低位桶与高位桶**：扩容时，原始桶的元素会按哈希值的高位与低位分配到新的桶数组中，确保数据均匀分布。例如，1 号桶的数据可能会被分配到原位置（1 号桶）或更远的位置（5 号桶）。
    
- **溢出桶的分配**：溢出桶的数据会继续分配到新桶中，避免长时间占用溢出空间。
    

---

## 总结

- **扩容方式**：Go `map` 支持两种扩容方式，翻倍扩容和等量扩容，分别通过负载因子和溢出桶数量触发。
    
- **GC 保护**：`extra` 字段用于保护溢出桶不被误回收，确保扩容过程中数据的完整性。
    
- **并发问题**：Go `map` 不支持并发写操作，写操作必须保证互斥，否则会导致数据竞态。
    
- **内存对齐**：Go 编译器自动优化字段对齐，确保内存访问效率。
    

通过这些改进和优化，Go `map` 在扩容、GC 以及并发操作方面都能实现高效且可靠的内存管理。