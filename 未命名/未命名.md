具体是怎么从全局队列拉取任务到本地队列的，这里我们后面会讲。当（从系统调用返回的）线程找不到可绑定的P时，它会把自己添加到休眠线程队列当中，并真正陷入休眠。 在这期视频当中，我们提到了线程的两种状态，一是**阻塞**，二是**休眠**。它们的共同点是都不会被CPU核心调度，不占据CPU资源。但**阻塞**更倾向于当前线程在等待一个**明确的外部事件**，比如系统调用返回。当那个事件完成后，线程可以被唤醒，继续执行之前的任务。而**休眠**则倾向于**没有明确的事件等待**，它只是在等待下一次调度器需要它的时候，复用这个休眠的线程，而不是创建一个新的。 接下来是这期视频的重头戏。我们会介绍很多碎片化的知识点，然后逐渐将它们拼成一个完整的流程。大家准备好了吗？ 让我们一起来学习一下Goroutine的生命周期。 首先，第一个场景就是**创建一个新的goroutine**。我们通过`go`这个关键字可以创建一个新的协程，关键字后面的函数就是这个协程要执行的任务，这个任务会运行在新创建的goroutine的**栈空间**当中。在创建这个goroutine时，我们会把它的状态从“空闲未初始化”（`_Gidle`）改为“准备运行”（`_Grunnable`）。 创建一个goroutine之后，我们的第一直觉是它应该被加入到某个P的本地队列，供GMP调度执行。所以，它究竟会加入到哪个P的本地队列呢？ 让我们看这张图。首先，线程在某个已经存在的协程（可能是`main`协程，也可能是其他协程）中，执行了`go func()`。也就是说，这个协程创建了一个新的协程。那么，这个新协程就会被**优先加入到当前执行它的goroutine所在的P的本地队列当中**。 当这个goroutine被调度执行时，它的状态就会从`_Grunnable`（可执行）变为`_Grunning`（执行中）。具体的状态定义，我们可以在`runtime/proc.go`这个文件当中看到。 而当某个goroutine因为某些代码层面的事件阻塞时，比如说，我们尝试从一个没有数据的、有缓冲的channel中读取数据，这个goroutine就会陷入到**goroutine级别的阻塞**。这种阻塞不会使线程阻塞，它只是让这个goroutine变为`_Gwaiting`（等待）状态。 其次，这个goroutine的指针会被**移动到对应事件的等待队列中**。比如说，让goroutine陷入阻塞的事件可能是我们刚刚提到的读空channel的操作，或者是Go语言内部自带的互斥锁。这些对应事件的数据结构，比如channel，其内部就维护了用于读操作阻塞的goroutine队列和用于写操作阻塞的goroutine队列，这里大家知道就好。这个G就会被移动到对应的等待队列当中。 那么现在就多出了一个问题：我们刚刚提到了“移动”一个协程。线程在G0栈上执行调度器代码后，选中某个G“取出”执行，这个“取出”的动作具体是什么呢？另外，刚刚提到的“移动”到channel的等待队列，又是怎么移动的呢？ 要解决这个问题，让我们先来学习一下P的本地队列的具体数据结构。在对应的源码当中我们可以看到，P的结构体里面有一个长度为256的数组，这个数组被称为**本地队列（runq）**，它的元素类型是goroutine的指针。所以，正如画面上显示的，一个P拥有一个容量为256的本地队列，每一个元素都是goroutine指针。并且再往下看，我们可以看到一个`runnext`字段，它是一个单独的goroutine指针，这是P的**VIP席位**，拥有最高的优先调度权，这里后面我们会说。 在G0上执行的调度器代码，我们可以直观地感受到它的逻辑。在这个调度函数当中，我们首先会检查P的`runnext`字段是否有goroutine。我们刚刚说到这是VIP席位，也就是说这个指针指向的goroutine会每一次都被优先检查，如果有，则先执行它。接下来，才会轮到本地队列这256个goroutine。 我们可以看到，这个本地队列有一个头指针和尾指针，我们简称为`head`和`tail`。事实上，这个本地队列是一个由头尾指针维护的**环形数组**。 具体让我们来看一个例子快速理解一下。在这个例子当中，我们的P本地队列有两个goroutine，分别是G1和G2。头指针和尾指针分别指向了第一个有效的goroutine和最后一个有效goroutine的后一个位置。 接下来，调度函数会从头指针取出一个goroutine，也就是说此时G1会被取出。这个**“取出”**的动作具体指的是什么呢？首先，线程会通过`head`指针访问到这个数组对应的goroutine指针，从而访问到goroutine对应的任务。在访问到之后，**`head`指针会向后移动一格**。如果用图片来展示的话就是这样：因为此时头尾指针之间维护的这个逻辑区间里已经没有G1这个元素了，所以在逻辑上，G1已经不存在于本地队列当中了。所以，具体的“取出”这个动作，指的就是它已经不在我们维护的头尾指针区间当中，也就不再被视为是有效的。 现在让我们想第二个场景：假设G1在它分配的时间片内**没有被执行完毕**，也就是说函数任务还没有到`return`那一步，时间片就到期了。那么这个时候，我们就会把G1**回填到`tail`这个指针对应的数组元素下标中**。具体来说，和刚刚一样，我们先通过头指针取到了G1的指针并执行。接下来，G1会被回填到`tail`指向的元素下标。然后，`head`和`tail`指针都会向后移动一格。这个时候我们会发现，头尾指针的区间当中仍然存在G1。这样的话，G1在下一次调度之后还有机会被执行到。 具体用图片展示就是这样：首先头指针指向G1，`tail`指向G2后面的一个位置。接下来G1被取出执行，然后被回填到`tail`的位置，最后`head`和`tail`都向后移动一格。G1仍然在我们维护的逻辑区间内，所以它仍然有机会在之后被执行到，具体取决于队列的长度。因为我们可以想到，假设这里有很多个goroutine，G1被放在队尾的话，它前面还会有很多goroutine需要被执行。 而对于像G2这种函数执行完毕的goroutine，它的状态则会从执行中变为`_Gdead`（死亡）。具体来说，对于这个goroutine的结构体，我们会把它放入到goroutine的对象池中复用；而对于这个goroutine对应的内存当中的那片栈空间区域，则会交给GC（垃圾回收机制）去回收。这也是我们下期视频想给大家分享的。 OK，让我们接着往后走。刚刚我们通过插叙的方式解释了什么叫做“取出”goroutine执行。它只是通过头尾指针去维护一个逻辑有效区间来实现的。而刚刚提到的“移动”到channel的等待队列又是怎么移动呢？这里我们就可以理解了。因为实际上当线程取出这个goroutine时，`head`指针会自然向后移动一格。也就是说，如果我们不把这个goroutine回填到尾指针，它就已经不存在于本地队列当中了。所以这个时候，我们只需要手动地把这个goroutine指针添加到对应的等待队列链表里，就可以实现“移动”了。 接着往下走，让我们来理解一下goroutine被放入队列的两种常见场景。 第一个就是我们通过`go`关键字新建了一个goroutine。刚才解释过了，它会被优先放置在当前执行的goroutine所在的P的本地队列的`runnext`指针中。而假设这个`runnext`指针已经指向了一个goroutine，则会把这个旧的goroutine放到队尾，把我们新创建的放到这个`runnext`指针中。 那么第二个场景就是那些等待事件阻塞的goroutine，比如说我们说的等待channel事件的G，事件触发时它们会从对应的goroutine等待链表当中放回到队列里。在Go 1.21+版本中，这两种情况都会尝试被放入`runnext`字段。 在调度的代码中，我们也提到过会先检查`runnext`字段。用一个例子来理解一下：在这张图中，线程正在执行一个goroutine任务，这个任务的函数里通过`go`关键字创建了一个新的协程。那么，新创建的这个协程就会被放到当前P的`runnext`字段中。 现在，让我们理清一下`runnext`字段设计的理念。我们假设没有这个`runnext`字段的设计，只有一个本地队列。还是用具体的例子来理解：这里我们有一个有缓冲channel，和刚刚一样，G2读取了一个无数据的channel，所以它会阻塞住。G2就被添加到这个channel的等待列表中。接下来，G1往这个channel写了一个数据，OK，事件触发了，G1访问了这个等待goroutine链表，将G2唤醒。由于没有`runnext`这个字段，我们很自然地把它放到本地队列的队尾。 让我们想一种最坏的场景：我们知道本地队列的长度是256。假设当前的G1在队头，那么G2会被放置到队尾。接下来`head`指针往后，调度执行了G1之后的下一个goroutine。在这个场景下，我们需要调度250多次，执行250多个任务，如果这些任务的执行时间都很长，每个任务都要跑满时间片，之后才能够轮到G2。这就会显著地增加延迟。我们往channel写数据，应该是希望接收方能够立马拿到数据往下执行的，这是一个最基本的**生产者-消费者模型**。所以，`runnext`字段就是为了优化这种场景的**时效性**，为了**低延迟**而设计的。 如果`runnext`里面已经有G了，我们会把新的goroutine替换掉旧的，并把旧的G放在本地队列的队尾。这种情况可能是我们在两次调度之间，短时间内创建了大量的G，至少创建了两次，赶在`runnext`的G被调度执行完之前，我们又创建了一个新的G，才会出现这样的情况。 当一个goroutine因为channel阻塞之后，它会从执行中变为`_Gwaiting`（等待资源）的状态。而当它取得资源，则会从`_Gwaiting`状态重新变为`_Grunnable`（可执行）状态，这个时候就要重新回到P的队列中，优先尝试`runnext`字段。 所以对于用`go`关键字新创建一个协程，或者等待的协程获取到资源，它们都会创建一个“可执行”的G。这个创立的动作实际上是由一个统一的函数来执行的，在我们贴出的源码当中可以看到这个函数叫做`ready`函数。首先它会先标记goroutine为`_Grunnable`，接下来会把它尝试放入到当前P的`runnext`字段。这些我们之前都说了。接下来，它会执行一个函数，叫做`wakep`。这个函数会检查是否需要唤醒空闲的P，也就是之前我们所说的检查是否还有空闲的P没有被线程给绑定。 我们兜兜转转一大圈，终于是要开始解释什么时候线程会被唤 ઉ醒了。所以我之前提到我们要讲解大量碎片的知识，但之后我们一定会把它串起来。 当有goroutine被标志为可运行之后，也就是我们之前提到的等待事件的G和新建的G，都会触发这个`ready`函数来检查是否有空闲的P没有被线程绑定。如果有空闲的P，那么我们可能会唤醒休眠的线程，或如果没有休眠的线程可以唤醒，我们则会新建一个线程去绑定这些P。 之前我们提到，在这张图中，蓝线往下是获取到P绑定之后的线程会执行的G0栈的调度代码。我们调度goroutine执行是有一个优先级排序的，其中也涉及到大量的细节。 接下来，让我们用四种场景来完全理解。 **第一种场景：空闲P中没有goroutine，而全局队列中有任务。** 首先，当线程M陷入到系统调用阻塞的时候，我们回顾一下，它会把这个P标记为空闲放到空闲队列当中。但是，这个P内部可能还有其他的goroutine存在着。所以说，空闲队列当中的P里面其实是可能还会有任务的。 在第一种情况下，我们设定为P1是当前活跃的队列，它当中的`runq`已经满了，并且它的`runnext`字段也指向了一个叫做G1的goroutine。接下来，它当中的某个任务又创立了一个新的G，这个G会加入到`runnext`字段，而旧的G1则会被添加到队尾，这个时候就超出了本地队列256的上限，出现了**溢出**的情况。 溢出指的是，当本地队列满时，我们还往里面创建新的协程，当前线程会在本地队列的头指针往后数128个G，将它们全部移动到全局队列当中，也就是本地队列长度的一半。然后再把我们新创建的G添加到队尾。这个例子听起来有些极端，但实际中，当本地队列快要满的时候，我们可能通过一个for循环快速创建了几十个甚至更多的goroutine，创建速度大于消耗速度，很容易就会占满。 接下来，就像我们之前所说的，创建了一个可运行的协程就会触发`ready`函数，这个函数会调用一个`wakep`函数去检查是否有空闲的P需要被绑定，这里P2就被选中。我们唤醒或新建一个新的线程M2，M2与P2绑定。 那么，M2调度goroutine的优先级是：首先是本地队列，本地队列没有任务，那么接下来就是全局队列。所以，**从全局队列取任务的条件之一是本地队列为空**，这是我们第一个得到的结论。 而它向全局队列取多少个任务呢？这里实际上是通过一个计算公式来得到的。简单来说，它是取几个数的最小值。第一个数是**128**，是拉取的上限。第二个数是**全局队列现有的goroutine总数**。最后一个是**全局队列goroutine总数除以P的数量，再加一**。 这里怎么理解呢？P越多，可以拉取的数量就越小。整个公式又是取三个数的最小值，所以P越多，我们每一次拉取的goroutine数量就会越少。这也体现了我们期望把goroutine平均分配到每个P的设计理念。P越多，我们往全局队列当中拉取的G就少，所以每个P都会少量拉取，从而保证不出现某一个P一次把所有goroutine都揽到自己身上的情况。 所以在这个例子当中，计算出的数量是65。这128个G就被拆分，65个G被加入到P2的队列当中。在这种情况下，我们就很大程度上实现了一定的负载均衡，缓解了P1的执行压力，利用到了两颗CPU核心。 所以这里你也可以看出，为什么我们说P是Processor。Processor的直译是处理器，也就是说，P实际上是Go语言**对于CPU核心的抽象**。一个核心会调度一个线程，而一个线程会对应一个P。这下我们就有了一个更高视角的理解。 而之前把它叫做“调度器”的“器”又该怎么理解呢？它本身其实不负责调度，所以这个“器”应该是**器皿的“器”，容器的“器”**，它是调度的容器。所以说，P翻译为“处理器”和“调度器”两种意思都是可以的。 **第二种情况：空闲的P2里面有剩余的任务，并且全局队列当中也有任务。** 就像我们之前提到的，被放置到空闲队列当中的P可能还有其他的goroutine任务。根据调度goroutine的优先级，我们会先处理本地的队列，也就是先处理之前剩余的任务。那么溢出到全局队列当中的128个G是不是在这个例子当中就无法被分摊缓解压力呢？ 其实这里还有一个调度的兜底策略。在调度函数中我们可以看到，**大约每61次调度，M会向全局队列当中拉取一个G**。这是一种“涓流”的思想，类似于电量快充满时我们会进行涓流充电。这里的“每61次”的设计理念也是类似的，首先是为了保证全局队列当中的G不会长期“饥饿”，不被调度到。其次，正如当前场景所示，P2本地队列当中还有任务需要执行，我们不可能抛弃掉当前的任务。这是一种把重心放到自己任务的同时，还分出一点点余力向全局队列拉取任务的设计思想。 **第三种情况：空闲的P2当中没有任务，而全局也没有任务。** 这种情况，我们设定为P1当中的goroutine并没有达到上限。我们新建了一个协程，它替代了`runnext`字段的旧G，旧G被加入到队尾。由于我们创建了一个可运行的G，触发了`ready`函数，我们同样将空闲的P2绑定到了一个唤醒或新建的线程M2。 这个时候，根据执行goroutine的优先级，本地队列为空，全局队列也为空。因为在我们这个场景设计当中，P等于2，如果P1不往全局队列塞G的话，全局队列就是空的。（在实际的应用当中，全局队列可能会有其他的P，比如P3、P4放入的G）。在当前这个场景下，是不是P2就无法缓解P1的执行压力呢？其实也不是。 我们接着往下看，我们默认net I/O事件当中的goroutine也为空。在这里的`netpoll`，我想之后给大家讲Go语言的网络I/O模型的时候再和大家讲。接着往下，优先级就到了**从其他P的队列窃取（Work Stealing）**。 那么他究竟是怎么窃取呢？它的触发条件很简单，也就是本地队列、全局队列和`netpoll`事件的goroutine都可用为空。他就会**随机选取一个P，对他窃取它当前持有的一半goroutine**。在这个例子当中，当然只能选中P1了。所以我们就把P1当中的任务窃取一半，也是从头指针往下。这64个G被窃取到P2当中。在这个情况下，我们通过了窃取，也是立刻实现了负载均衡，分担了P1的处理压力。 **第四种情况：空闲的P2内有剩余的任务，并且全局没有任务。** 这种情况下，和刚刚一样，P1因为没有满，所以没有溢出G到全局队列，而P2当中有之前剩余的G。这个时候我们依然来看执行优先级：本地队列有G吗？有的，所以我们要优先执行剩余的任务。从这个情况下来看，好像也无法分担到P1的执行压力。 但是我们还可以再细化这种情况：假设之前剩余的N个G非常少，那么它可能很快就执行完毕内部队列的任务，于是因为本地队列为空、全局队列为空，他也会去触发窃取，从而分担P1的处理任务压力。那如果其中的剩余的N个G很多呢？这种情况下，那肯定是优先执行自己的任务，这也是一种执行优先级的设计思想。 好了，接下来让我们把刚刚讲到的所有东西串一遍吧。 首先是Goroutine的生命周期。goroutine可以通过`go`关键字创建出来，它的状态会从`_Gidle`到`_Grunnable`。当goroutine因为互斥锁或读写channel阻塞时，它的状态会从运行中变为`_Gwaiting`，对应的goroutine指针会被移到对应的等待列表里。这些让goroutine阻塞的数据结构内部都会维护这样一个等待的链表。事件触发之后，它们会从等待状态变为`_Grunnable`。 在这些情况下，我们都需要去把可执行的goroutine放入到本地队列当中，它们都会统一调用一个叫做`ready`的函数。这个`ready`函数负责把它们标记为可运行，并尝试放入到`runnext`字段。然后，立刻调用一个`wakep`去检查是否有空闲的P没有被线程绑定。`wakep`函数里面的逻辑，我们理解到这个部分就好。 我们通过四种情况的例子能够感受到，当有新任务出现时，空闲的P就应该被唤醒来工作，这样可以尽可能利用多个CPU核心，再通过我们设计的一系列调度细节去实现一定的负载均衡。这也是为什么当我们创建一个可执行的G时，我们会来唤醒P，这其中也是有因果关系的。 接下来就是执行优先级。当本地队列任务不足时，我们就会去全局队列取任务，通过公式来计算一次取得任务数量。这个公式，P越多，每一次取就越少。当本地队列、全局队列都没有任务，且`netpoll`也没有任务的时候，它就会窃取某一个随机P的一半任务。 当某个goroutine触发系统调用，线程M会和P进行解绑，标记P为空闲并将其放到空闲P的队列当中，和当前G一起陷入到阻塞。系统调用返回之后，M会在当前持有的G的栈内，执行一个函数寻找原先的P；失败则切换到G0栈，执行函数寻找任意空-闲的P。成功的话回到GMP调度流程，如果都失败，则会把当前G放到全局队列，供其他活跃的M-P组调度，自身则陷入休眠，供调度器后续调度。 而调度的逻辑，则是之前我们说到的，当我们新建或唤醒了一个G，让它的状态变为`_Grunnable`的时候，会调用`ready`函数，从而可能唤醒当前休眠的线程。所以到这里，你会发现整个逻辑彻底地闭环了。我们付出了很多的努力，终于让零碎的知识，变为了一个完整的知识体系。