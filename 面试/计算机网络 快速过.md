### HTTP 常见的状态码有哪些？

2xx 开头表示成功，比如 200 OK。
3xx 开头表示重定向，比如 301 永久搬家，304 东西没变用缓存。
4xx 开头表示客户端请求有问题，比如 404 Not Found 找不到，403 Forbidden 不让看。
5xx 开头表示服务器那边出问题了，比如 500 Internal Server Error 服务器内部出错。
HTTP 常见字段有哪些？

就是请求和响应头里带的一些说明信息，像 Host 说明访问哪个网站，Content-Type 说明内容格式，Cookie 用来带用户登录状态之类的信息，Cache-Control 指示怎么缓存。
### GET 和 POST 有什么区别？

通常 GET 用来拿数据，参数放 URL 里；POST 用来交数据，参数通常放在请求体（body）里。GET 一般不改服务器数据，POST 会改。GET 请求能缓存，POST 一般不行。
### GET 和 POST 方法都是安全和幂等的吗？

按规矩说，GET 应该是安全（不改变服务器数据）且幂等（请求一次和多次效果一样）的。POST 通常两者都不是。但实际开发中不一定严格遵守。
### HTTP 缓存有哪些实现方式？

主要就两种：强制缓存和协商缓存。
### 什么是强制缓存？

就是浏览器看自己存的这份缓存还没到期（根据 Cache-Control 或 Expires），就直接用了，不跟服务器打招呼。
### 什么是协商缓存？

就是强制缓存过期了，浏览器带点儿上次缓存的信息（像 ETag 版本号或 Last-Modified 时间）去问服务器：“我这份旧的还能用吗？” 服务器对比一下，没变就回个 304，让用旧的；变了就回 200 带上新的。
### HTTP/1.1 的优点有哪些？

主要优点是简单，基于文本容易懂；而且通用，用得非常广泛。
### HTTP/1.1 的缺点有哪些？

缺点主要是：性能上有队头阻塞 (Head-of-Line Blocking) 问题，意思是在同一个 TCP 连接上，**响应必须按请求顺序返回**，所以前一个响应处理慢或异常了就会阻塞后续所有响应的发送和接收，导致连接效率低下；**此外还有明文传输不安全；请求头部信息冗余；协议无状态管理起来也比较麻烦。**
### HTTP/1.1 的性能如何？

性能比 1.0 强，主要是靠长连接 (Keep-Alive)，这个机制指的是在一个 TCP 连接建立后可以传输多个 HTTP 请求和响应，**避免了像 HTTP/1.0 那样每个请求都重新建立 TCP 连接（三次握手）的开销**。但它的主要性能瓶颈还是队头阻塞（前面已解释），这**限制了单个连接上的并发处理能力**，所以在**复杂页面场景下性能一般**。
### HTTP 与 HTTPS 有哪些区别？

HTTPS 就是给 HTTP 加了层 SSL/TLS 安全协议，传输内容是加密的，更安全。用的端口不一样（HTTP 80, HTTPS 443），HTTPS 服务器需要证书。
### HTTPS 解决了 HTTP 的哪些问题？

解决了 HTTP 明文传输被窃听、被篡改、服务器被假冒这三大安全风险。
HTTPS 是如何建立连接的？其间交互了什么？

比 HTTP 多一步 TLS 握手过程。逻辑上是：双方先确认对方身份（主要是客户端验证服务器证书），然后协商确定本次通信使用的加密套件，最后安全地生成和交换用于加密应用数据的会话密钥。
### HTTPS 的应用数据是如何保证完整性的？

通过消息认证码 (MAC) 机制。发送数据时，会根据数据内容和双方共享的会话密钥算出一个 MAC 值，附加在加密数据旁。接收方解密后，用同样方法计算 MAC，与收到的 MAC 比对，一致则说明数据未被篡改。
### HTTPS 一定安全可靠吗？

协议本身设计是安全的。但实际安全性依赖于正确的证书验证（比如用户不能忽略浏览器警告）和客户端环境的安全（比如操作系统信任的根证书列表未被污染）。否则，仍可能遭受中间人攻击。
### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

最主要的提升是默认启用了长连接 (Keep-Alive)，也就是可以用一个 TCP 连接处理多个 HTTP 请求，省去了频繁建立和断开 TCP 连接（三次握手）的开销。
### HTTP/2 做了什么优化？

核心是多路复用，允许在一个 **TCP 连接上并行、交错地处理多个请求/响应流**，**解决了 HTTP/1.1 应用层的队头阻塞问题。还有头部压缩 (HPACK)、二进制传输、服务器推送等也提升了效率**。
### HTTP/3 做了哪些优化？

最大改变是底层换用了基于 UDP 的 QUIC 协议。因为 HTTP/2 虽解决了应用层阻塞，但 TCP 协议本身为了保证数据按序到达，**在网络丢包时会暂停所有流的数据交付**，这叫 TCP 层的队头阻塞。QUIC 在 UDP 之上为每个流独立管理可靠性，一个流的丢包不影响其他流，因此彻底解决了队头阻塞问题。而且 QUIC 连接建立更快，还能支持连接迁移（切换网络时保持连接）

### RSA vs ECDHE 握手区别（精简版）：
- **RSA 交换：**
    
    - 客户端**生成**一个秘密（预主密钥）。
    - 用服务器证书里的**长期公钥加密**这个秘密，发给服务器。
    - 服务器用自己的**长期私钥解密**得到秘密。
    - **缺点：** 没有**前向安全性**（服务器私钥丢了，历史通信可能被解密）。
- **ECDHE 交换：**
    
    - 客户端和服务器都**临时生成**密钥对。
    - 双方交换**临时公钥**（服务器会用长期私钥**签名**自己的临时公钥信息，证明身份）。
    - 双方**各自独立**用自己的临时私钥和对方的临时公钥，通过算法**算出**同一个秘密（预主密钥），这个秘密**不直接在网络上传输**。
    - **优点：** 有**前向安全性**（服务器私钥丢了，不影响历史通信安全）。

### TCP 基础与核心作用

- **为什么需要 TCP:**  
    TCP 在不可靠的 IP 层之上，通过**序列号、确认和重传机制**，提供了**可靠、有序的字节流传输服务。**
    
- **什么是 TCP 连接:**  
    TCP 连接并非物理链路，而是通信双方为保证可靠传输共同维护的、以**四元组为唯一标识的一套状态信息（如序列号、窗口大小）**。
    

### TCP 连接建立：三次握手

- **为什么是三次握手:**  
    三次握手既能可靠地同步双方的初始序列号，又能**防止已失效的连接请求报文被服务器错误地建立连接**。
    
- **三次握手：客户端 SYN 包丢失:**  
    若客户端的 SYN 包丢失，客户端会因收不到 SYN-ACK 而超时，并多次重传 SYN。
    
- **三次握手：服务器 SYN-ACK 包丢失:**  
    若服务器的 SYN-ACK 包丢失，服务器会超时重传 SYN-ACK，同时客户端也可能因等不到而超时重传 SYN。
    
- **三次握手：客户端最后 ACK 包丢失:**  
    客户端认为连接已建立，但服务器会因收不到 ACK 而超时重传 SYN-ACK，客户端收到后会再次发送 ACK。
    

### TCP 连接断开：四次挥手与 TIME_WAIT

- **为什么是四次挥手:**  
    因为 TCP 是全双工的，一方关闭发送通道（FIN）后，另一方可能仍有数据要发送，所以需要各自独立地关闭。
    
- **TIME_WAIT 状态为何必要:**  
    TIME_WAIT 状态确保了**最后的 ACK 能可靠到达**，并等待足够时间**让网络中的旧报文消失**，**防止干扰新连接**。
    
- **四次挥手：客户端 FIN 包丢失:**  
    客户端会因收不到 ACK 而超时重传 FIN。
    
- **四次挥手：服务器对 FIN 的 ACK 丢失:**  
    客户端会超时重传 FIN，服务器收到后会再次发送 ACK。
    
- **四次挥手：服务器 FIN 包丢失:**  
    服务器会因收不到最后的 ACK 而超时重传 FIN。
    

### TCP 状态问题与故障排查

- **大量 CLOSE_WAIT 状态暗示什么:**  
    大量 CLOSE_WAIT 状态通常意味着被动关闭方的应用程序收到了对端的 FIN 后，因代码逻辑问题（如 bug 或阻塞）没有及时调用 close 关闭连接。
    
- **CLOSE_WAIT 状态详解:**  
    CLOSE_WAIT 状态表示 TCP 栈已收到对端 FIN 并回了 ACK，但正等待本地应用程序调用 close。
    
- **大量 TIME_WAIT 的危害:**  
    大量 TIME_WAIT 会消耗系统内存和 CPU，更关键的是会耗尽客户端可用的临时端口号，导致无法建立新的出站连接。
    
- **如何优化 TIME_WAIT 过多:**  
    可开启 tcp_tw_reuse 复用 TIME_WAIT 状态的 socket 用于新的出站连接，或在应用层使用长连接减少连接关闭次数。
    
- **tcp_tw_recycle 的问题:**  
    tcp_tw_recycle 会对服务端生效，其依赖的时间戳假设在 NAT 环境下会被破坏，导致误丢合法 SYN 包，因此已被废弃。
    

### TCP vs. UDP

- **为什么还需要 UDP:**  
    UDP 开销极小、速度快，适用于那些能容忍少量丢包但对实时性要求高的场景，如音视频、游戏、DNS。
    
- **TCP vs UDP 核心区别与选择:**  
    TCP 可靠但开销大，像打电话；UDP 不可靠但快，像寄平信。要求数据完整用 TCP，追求实时性用 UDP。
    

### TCP 内部机制与实现细节

- **accept 在握手哪个阶段后返回:**  
    accept 在三次握手完全成功、连接进入 ESTABLISHED 状态并被放入全连接队列后，才会返回。
    
- **listen 的 backlog 参数作用:**  
    backlog 参数主要影响已完成三次握手但等待 accept() 的全连接队列的最大长度。
    
- **不调用 accept，握手能完成吗:**  
    可以，三次握手由内核独立完成，成功后连接会放入全连接队列，等待应用程序调用 accept 来取走。
    
- **TCP 头关键信息:**  
    TCP 头包含源/目的端口号、序列号/确认号、窗口大小（流量控制）、校验和（检错）以及各种标志位（SYN/ACK/FIN/RST）。
    
- **如何区分大量连接:**  
    系统通过四元组（源IP、源端口、目标IP、目标端口）来唯一标识和区分每一个 TCP 连接。
    
- **TCP 和 UDP 能监听同个端口吗:**  
    可以，因为 IP 层的协议字段会区分 TCP 和 UDP 报文，操作系统会分别将它们交给各自独立的协议栈处理。
    
- **ISN 如何产生:**  
    ISN 结合了随时间递增的时钟和一个基于连接四元组的哈希计算，以保证其随机、不可预测且短时不重复。
    
- **为何 TCP 要协商 MSS:**  
    TCP 协商 MSS 是为了避免 IP 层对 TCP 段进行分片，从而在发生丢包时，TCP 只需要重传一个 MSS 大小的数据段，提高重传效率。
    

### TCP 安全性

- **SYN Flood 攻击:**  
    攻击者发送大量伪造源 IP 的 SYN 包，占满服务器的半连接队列，导致正常用户无法建立连接。
    
- **如何防御 SYN Flood:**  
    可调大半连接队列、缩短超时，或启用 SYN Cookies 机制，通过特殊序列号绕过半连接队列来验证合法客户端。
    

### TCP 观察与诊断

- **如何查看 TCP 连接状态:**  
    可用 netstat -napt 或更高效的 ss -napt 命令查看连接状态（如 ESTABLISHED, TIME_WAIT）。
    

### TCP 连接状态与异常处理

- **客户端死机/断网，服务器会怎样:**  
    若未开启 TCP Keepalive，连接会在服务器端一直处于 ESTABLISHED 状态；若开启，服务器会通过发送探测包发现连接失效并关闭。
    
- **服务器进程崩溃，连接会怎样:**  
    操作系统内核会接管崩溃进程的 socket，并自动向客户端发送 FIN 包，启动正常的四次挥手关闭流程。
    
- **主机断电 vs 进程崩溃:**  
    主机断电对端表现为通信超时无响应；进程崩溃对端则会收到 FIN 或 RST，看到一个正常的连接关闭或重置流程。
    
- **客户端宕机重启后立即重连:**  
    服务器端的旧连接可能还未超时，它可能会对新 SYN 回复 RST，导致重连失败，需等待旧连接状态清理。
    
- **客户端拔网线后有/无数据发送:**  
    若服务器发送数据，会因收不到 ACK 而超时断连；若无数据发送且未开启 Keepalive，连接会一直处于 ESTABLISHED 状态。
    

### TCP 可靠性：重传机制

- **TCP 如何应对丢包:**  
    通过超时重传和快速重传机制来重新发送丢失的数据包。
    
- **超时重传:**  
    发送方为发出的数据启动计时器，若在超时前未收到 ACK，则认为包已丢失并重传。
    
- **快速重传:**  
    发送方收到三个或以上对同一数据包的重复确认 ACK 时，不等超时就立即重传被认为丢失的那个包。
    
- **SACK (选择性确认):**  
    SACK 允许接收方在 ACK 中明确告知发送方收到了哪些不连续的数据块，使发送方能更精确地只重传真正丢失的部分。
    
- **SACK 如何工作:**  
    接收方通过在 TCP 选项中附加 SACK 块，报告已收到的非连续数据范围，帮助发送方精确识别丢包。
    

### TCP 效率：滑动窗口、流量控制与拥塞控制

- **滑动窗口如何提高效率:**  
    滑动窗口允许发送方在收到 ACK 前连续发送多个数据包，将等待 ACK 的时间用于数据传输，从而提高吞吐量。
    
- **窗口大小由谁决定:**  
    主要由接收方通过在 ACK 包中通告的接收窗口 (rwnd) 决定，用于流量控制。
    
- **流量控制:**  
    通过接收方通告的接收窗口 (rwnd) 来控制发送方的发送速率，防止淹没接收方。
    
- **零窗口死锁与持续计时器:**  
    发送方收到零窗口后会启动持续计时器，到期后发送窗口探测包以获取最新的窗口大小，防止死锁。
    
- **拥塞控制与流量控制的区别:**  
    流量控制关注接收方能力（点对点），拥塞控制关注网络全局承载能力；发送速率取两者窗口的最小值。
    
- **拥塞控制如何工作:**  
    通过慢启动、拥塞避免、快重传和快恢复等算法，根据网络丢包情况动态调整拥ز塞窗口 (cwnd) 大小。
    
- **拥塞控制算法阶段:**  
    主要包括慢启动（指数增长）、拥塞避免（线性增长）、拥塞发生（窗口减小）和快速恢复（避免重回慢启动）四个阶段。
    
- **快速恢复机制:**  
    在快速重传触发后，避免退回到低效的慢启动阶段，使 TCP 能更快恢复传输速率。
    

### TCP 连接建立：服务器端队列与优化

- **服务器端如何管理连接请求:**  
    通过半连接队列 (SYN Queue) 存放待完成三次握手的连接，和全连接队列 (Accept Queue) 存放已完成握手等待 accept() 的连接。
    
- **Accept 队列满了会怎样:**  
    服务器可能不再响应最后一个 ACK 或直接丢弃，导致新连接建立失败。
    
- **SYN 队列满了会怎样:**  
    服务器无法处理新的 SYN 请求，通常会直接丢弃，导致正常用户也无法连接。
    
- **SYN Cookies 如何工作:**  
    当 SYN 队列满时，服务器通过一个特殊计算的序列号 (Cookie) 来验证合法客户端的 ACK，从而绕过 SYN 队列直接建立连接。
    
- **优化三次握手性能:**  
    可使用 TCP Fast Open (TFO) 在 SYN 包中携带少量数据，减少一次 RTT 延迟。
    
- **能否“绕过”三次握手:**  
    标准 TCP 不能绕过，TFO 是在握手过程中提前传数据，而非跳过握手。
    

### TCP 面向字节流与粘包问题

- **TCP 面向字节流的理解:**  
    TCP 视数据为无边界的连续字节序列，不保留应用层的消息边界。
    
- **如何解决粘包问题:**  
    在应用层通过定义消息边界（如特殊字符、固定长度或长度字段）来解决。
    

### QUIC 协议 (基于 UDP 的可靠传输)

- **如何在 UDP 上实现可靠传输:**  
    需在应用层实现 TCP 的核心机制：序列号与确认、重传、流量控制和拥塞控制。
    
- **UDP 可靠传输的例子:**  
    最典型的例子就是 QUIC 协议，它在 UDP 之上实现了可靠传输并解决了 TCP 的诸多痛点。
    
- **TCP vs QUIC 对比:**  
    QUIC 基于 UDP，连接建立快 (0/1-RTT)，无队头阻塞，支持连接迁移，但可能被防火墙限制。
    
- **QUIC vs TCP SACK:**  
    QUIC 的确认机制基于 Packet Number，且重传使用新 Packet Number，无重传歧义，比 TCP SACK 更精确高效。
    
- **QUIC 如何解决队头阻塞:**  
    QUIC 内置多个独立的流，一个流的数据包丢失不影响其他流的数据交付。
    
- **QUIC 的流量控制:**  
    通过连接级和流级两级流量控制，比 TCP 的单连接级流控更精细。
    
- **QUIC 的拥塞控制:**  
    原理与 TCP 类似，但因在用户态实现而更灵活、易于部署新算法，且基于更精确的信号。
    
- **QUIC 如何实现连接迁移:**  
    通过独立于 IP 地址的连接 ID (Connection ID) 来标识连接，实现网络切换时连接不中断。
    

### TCP 连接建立与关闭的边界情况

- **连接未监听端口会怎样:**  
    服务器内核会直接回复一个 RST (Reset) 包，客户端连接被拒绝。
    
- **连接已建立但未 accept:**  
    连接会成功建立并存在于全连接队列中，直到被 accept() 或超时清理。
    
- **四次挥手能否变三次:**  
    可能，如果被动关闭方在收到 FIN 时恰好也无数据要发，可以将 ACK 和自己的 FIN 合并为一个包发送。
    
- **TCP 的局限性:**  
    主要局限性有：内核实现导致升级困难、连接建立延迟高、队头阻塞问题、以及连接无法在网络切换时迁移。

### IP 基础与寻址

- **IP 核心职责:**  
    IP 协议的核心职责是寻址和路由，即为设备分配 IP 地址并在网络间转发数据包。
    
- **A/B/C 类地址:**  
    早期 IP 地址按首字节分为 A/B/C/D/E 类，这种固定划分方式因浪费地址而被 CIDR 取代。
    
- **CIDR (无类别域间路由):**  
    CIDR 使用 IP 地址加斜杠和前缀长度（如 /24）的方式，灵活地划分网络和主机位，解决了地址浪费问题。
    
- **公有 IP 与私有 IP:**  
    公有 IP 全球唯一，用于互联网；私有 IP（如 10.x、192.168.x）用于局域网内部，通过 NAT 技术访问公网。
    
- **私有地址与 ABC 类关系:**  
    是的，私有 IP 地址段是从原 A、B、C 类地址空间中划拨出来的，但现代管理方式已基于 CIDR。
    

### IP 路由与转发

- **数据包如何知道下一步:**  
    设备根据数据包的目标 IP，在本地路由表中查找最长前缀匹配项，以确定下一跳路由器和出站接口。
    
- **IP 分片与重组:**  
    当 IP 包大于下一跳网络的 MTU 时，发送方或中间路由器会将其分片，最终由目标主机负责重组。
    

### IPv6

- **IPv6 主要改进:**  
    IPv6 最大的改进是 128 位地址空间，同时简化了头部、无需 NAT、并更好地支持移动性和安全性。
    

### IP 辅助协议

- **DNS (域名系统):**  
    DNS 负责将人类易记的域名（如 www.google.com）解析为机器可用的 IP 地址。
    
- **ARP (地址解析协议):**  
    ARP 用于在同一局域网内，通过广播 IP 地址查询来获取目标设备的物理 MAC 地址。
    
- **DHCP (动态主机配置协议):**  
    DHCP 用于主机启动时自动从服务器获取 IP 地址、子网掩码、网关和 DNS 等网络配置信息。
    
- **NAT (网络地址转换):**  
    NAT 通过修改数据包的源/目的 IP 和端口，让多个使用私有 IP 的设备能共享公有 IP 访问互联网。
    
- **ICMP (互联网控制消息协议):**  
    ICMP 用于在 IP 设备间传递控制和差错报文，是 ping 和 traceroute 等网络诊断工具的基础。
    

### 网络诊断与特殊地址

- **ping 工作原理:**  
    ping 利用 ICMP 的 Echo 请求和 Echo 回复报文来测试目标主机的可达性和测量往返时间 (RTT)。
    
- **traceroute 工作原理:**  
    traceroute 通过发送递增 TTL 值的 IP 包，并利用路由器返回的 ICMP 超时差错报文，来逐跳探测到目标地址的网络路径。
    
- **断网能否 ping 通 127.0.0.1:**  
    能，因为 127.0.0.1 是回环地址，数据包完全在操作系统内核内部循环，不经过物理网卡。
    
- **ping 127.0.0.1 vs ping 本机IP:**  
    ping 127.0.0.1 完全在内核协议栈内部循环；ping 本机实际 IP 会经过网卡驱动层再返回，路径稍长。
    
- **127.0.0.1 vs localhost vs 0.0.0.0:**  
    127.0.0.1 是回环 IP 地址；localhost 是默认解析到该地址的主机名；0.0.0.0 用于服务器监听，表示监听所有可用的本地 IP 接口。