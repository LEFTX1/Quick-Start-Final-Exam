 ![[黑白整齐简历模板 (3).pdf]]

# 技术描述部分
## Context 包
![[Pasted image 20250415194100.png]]
Context主要使用于 **调控协程之间的生命周期联动和传递元数据** 的问题。context接口有四种基本实现，分别是**空的backgroundcontext，带取消功能的cancelcontext以及带超时取消功能的timeercontext还有携带元数据value的valuecontext**,他们都可以调用四种派生方法来创建对应的子context形成一个**context树状结构。**

![[context树组成图示.svg|725]]

![[context树双向连接.svg]]

![[cancel向下传播.svg|600]]
### channel 的 csp模型是什么？
csp模型强调**通过通信来共享内存** ，具体来说就是多个并发实体Goroutine之间应该是相互独立的，它们之间的交互应该通过 Channel 来进行而不是直接访问彼此的内存数据。

### 详细说说 Context 的取消信号是如何在 Goroutine 之间传递的吗？
context内部有一个map结构来储存从他派生出来的子context，从而形成父子结构的树状结果。当一个 Context 被取消时 ，**它会遍历所有它的子 Context， 向下传递去触发它们的取消逻辑**, 也就是**关闭 (close) 那个标志着context存活信息的只读channel，这个只读 Channel**由 Done() 方法返回。读取这个channel 会因为channel无数据而阻塞，但当channel关闭后会读取到零值，也就是一个空结构体，那么使用select语句监听这个channel的case语句就会执行下去，而这一行case语句就是我们处理context取消之后的操作。

### 可以谈谈 `context` 包吗？按你的理解，它主要是用来干嘛的？"

**(候选人 - 我):** "嗯，`context` 包啊... 对，这个在 Go 里挺核心的，特别是做并发或者网络服务的时候基本绕不开。我的理解是，它主要是 Go 提供的一套标准方法，用来处理那些需要跨越多个代码部分、特别是跨 goroutine 边界的事情。比如说... 控制一个操作到底该跑多久，或者像广播一个信号说‘嘿，这个任务相关的各位，都停下吧！’，有时也用它顺便带点像请求 ID 这样的小信息。当你有好几个 goroutine 为一个初始请求工作时，它能帮你有效地管理这些复杂性。"

### `context` 具体是怎么做到像取消或者超时这种功能的？它背后的机制大概是怎样的？"

**(候选人 - 我):** "哦，这个啊，它底层很大程度上是利用 channel 来实现的。当你创建一个_可以被取消_的 context 时——比如用那个 `WithCancel` 函数，或者像 `WithTimeout` 这种带超时的——你实际上会得到一个新的 context 对象。这个对象里面有个 `Done()` 方法，它会返回一个 channel。

关键就在这儿：当这个 context 被要求取消时（不管是你手动调了它的 `cancel` 函数，还是它的时间到了），Go 就会把那个 `Done()` 返回的 channel 给关闭掉。

那么，任何拿到了这个 context 的 goroutine，就可以在自己的代码里用一个 `select` 语句块，去监听（或者说等待）这个 `ctx.Done()` channel。一旦那个 channel 被关闭，`select` 里的对应 case 立刻就能触发。这就是那个‘信号’！Goroutine 就知道：‘哦，该收尾了’，然后它就可以优雅地停止当前的工作，清理需要清理的东西，然后退出。

对了，通常在你发现 `Done()` 被关闭后，还可以调一下它的 `Err()` 方法，看看具体是_为什么_被取消的——是被人手动取消了呢，还是时间到了触发了超时。"

### 提到了 `WithCancel` 和 `WithTimeout`，那还有其他常见的方式来创建 context 吗？它们之间有啥不一样？"

**(候选人 - 我):** "嗯，除了这两个，还有几个也挺常用的。有个 `WithDeadline`，它跟 `WithTimeout` 有点像，但它不是说‘几秒后超时’，而是让你设一个具体的_时间点_，比如‘到下午五点整必须结束’。`WithTimeout` 和 `WithDeadline` 这俩都是跟时间限制有关的，而且它们也都会返回那个 `cancel` 函数，万一你想在时间到之前就提前结束任务也行。

然后还有一个挺不一样的，就是 `WithValue`。这个函数跟取消、超时没关系，它的作用纯粹是在 context 里附加一些数据，比如用户 ID 或者追踪 ID 之类的，让这些数据能一路传递下去，省得每个函数都得显式地加个参数。

哦对了，所有这些 `With` 开头的函数——`WithCancel`, `WithTimeout`, `WithDeadline`, `WithValue`——创建出来的都是子 context。有个挺方便的特性是，如果父 context 被取消或者超时了，它所有的子 context 也会自动跟着一起被取消，这个效果会级联下去。"

### 我们再说说 `WithValue`。你说它是带数据的，用它的时候有什么需要特别注意的地方吗

**(候选人 - 我):** "啊，`WithValue`... 对，用这个确实得稍微留点神。通常的建议是，用它来传递那些真正跟整个请求范围相关的信息——就是那些跨越不同处理阶段、但本身又不是核心业务逻辑必须的东西，比如我们刚说的追踪 ID，或者是一些身份认证相关的信息。

但是，有几点很重要：一般_不推荐_用它来传普通的函数参数或者依赖。如果一个函数完成工作_必须_要某个数据，最好还是明确地通过函数参数传进去。过度依赖 `WithValue` 会让代码的依赖关系变得不那么清晰，有点像是在用隐性的全局变量，维护起来可能比较麻烦。

另外一个关键点是用作 key 的东西。最佳实践是用你自己定义的、非导出的类型来做 key，而不是直接用字符串比如 `"userID"`。这样可以避免在不同的包里不小心用了相同的字符串 key 导致冲突。还有就是，你用 `Value()` 方法取值的时候，拿到的是 `interface{}` 类型，所以你得自己做类型断言，这也多了步操作，而且如果类型不对还得处理可能出现的 panic。"

### 经常看到 `context.Background()` 和 `context.TODO()`，这俩有啥区别？什么时候该用哪个呢？"

**(候选人 - 我):** "对，`Background` 和 `TODO`。它们俩基本上就是所有 context 链条的‘根’，是你可以开始构建其他 context 的起点。它们本身都是空的，永远不会被取消，也没有截止时间，也不带任何值。

主要的区别其实在于_使用的意图_和_代码的清晰度_：

- `context.Background()` 是官方推荐的、标准的用法。你应该在 `main` 函数里、或者初始化代码、测试代码这些地方用它，作为整个调用链的最顶层 context，当你不知道还能从哪儿获取父 context 时，它就是那个默认的起点。它代表一个清晰定义的、新的处理流程的开始。
- `context.TODO()` 呢，它的名字就暗示了它的意思——‘待办事项’！它表示‘我现在还不确定这里应该用哪个 context’，或者‘这块代码以后需要接入一个合适的 context，但现在还没弄好’。它就像个占位符，提醒你自己或者别人这里还有工作要做。所以，如果你在一个函数里不知道该从哪里获取 context，或者暂时无法获取时，可以用 `TODO()` 顶一下。但理想情况下，随着代码的完善，`TODO()` 最终应该被替换成从调用者传过来的、有实际意义的 context。

简单说就是：`Background` 是推荐的、明确的根，`TODO` 是个临时的、表明‘有待改进’的标记。"

###  结合你的实际项目经验来看，用 `context` 时有哪些比较好的实践方式，或者说常见的坑需要尽量避开？"

**(候选人 - 我):** "嗯……根据我的经验，确实有几点挺重要的：

- **怎么传：** 这个基本是铁律了，`context` 应该总是作为函数的**第一个参数**，而且大家通常都把它命名为 `ctx`。这算是 Go 社区的约定俗成了。
- **放哪里：** 通常，别把 `context` 塞到结构体（struct）的字段里。它应该是显式地在函数调用之间传递的，跟具体的对象实例的生命周期分开。
- **最容易踩的坑：** 可能就是光传了 `ctx`，但是忘了在自己的 goroutine 里_检查_它！尤其是在那些可能跑挺长时间的循环里，或者在等 channel 的地方，一定要在 `select` 里加上 `case <-ctx.Done():` 这个分支。不然，即使外面取消了 context，你那个 goroutine 也收不到信号，还在傻跑，这就可能导致资源泄露。
- **`WithValue` 的使用：** 就像我们前面聊的，别滥用它。只用它传递那些真正跨请求范围的、辅助性的数据。
- **别忘了 `cancel`：** 当你用 `WithCancel` 或者带超时的那几个函数创建了 context 后，它们会返回一个 `cancel` 函数。记得要调用它！最常见也最保险的做法是用 `defer cancel()`，这样能确保无论函数是正常结束还是中途 panic，这个 `cancel` 都能被调用，相关的资源能及时释放。
- **错误检查：** 当 `ctx.Done()` 被触发后，可以通过 `ctx.Err()` 来获取具体是哪种错误（比如是被取消了还是超时了），根据这个错误信息做相应的处理或者记录日志挺有用的。


## GMP 模型
![[Pasted image 20250419194134.png]]

### **Q1: 请解释一下 Go 的 GMP 模型是什么？**

**A:** GMP 是 Go 语言并发调度的核心模型。G 代表 Goroutine（轻量级并发单元），M 代表 OS 线程（执行者），P 代表逻辑处理器（调度上下文，数量由 GOMAXPROCS 控制）。GMP 模型通过 P 将大量的 G 高效地调度到少量的 M 上执行，实现了低开销的并发和对多核 CPU 的充分利用。其核心思想是用 M:N 调度（多个 G 跑在 N 个 M 上）并引入 P 作为中间层来管理 G 队列和资源，实现高效调度。

 ### **Q2: G, M, P 分别是什么？它们之间是如何协作的？**

**A:**

- **G (Goroutine):** Go 程序中的并发任务单元，栈小，用户态调度，开销低。
    
- **M (Machine):** 操作系统线程，实际执行 G 代码的载体。
    
- **P (Processor):** 逻辑处理器，M 必须获得一个 P 才能执行 G。P 维护一个本地 G 队列 (LRQ)，管理调度状态和资源。P 的数量决定了并行度。
    
- **协作：** M 需要绑定一个 P 才能工作。M 从绑定的 P 的 LRQ 获取 G 并执行。如果 LRQ 为空，M 会尝试从全局队列 (GRQ) 获取，或从其他 P 的 LRQ "窃取" (Work Stealing) G 来执行。执行 G 的过程中可能发生切换、阻塞等，触发相应的调度逻辑。
    

 ###  **Q3: Go 的调度器是如何工作的？能谈谈工作窃取机制吗？**

**A:** Go 调度器基于 GMP 模型。每个 P 有一个本地 G 队列 (LRQ)，还有一个全局 G 队列 (GRQ)。M 优先执行其绑定 P 的 LRQ 中的 G。  
**工作窃取 (Work Stealing):** 当一个 P 的 LRQ 为空，并且 GRQ 也为空时，与之绑定的 M 不会闲置。它会随机选择另一个 P，并尝试从那个 P 的 LRQ 尾部“窃取”一半的 G 到自己的 LRQ 中来执行。这有助于实现负载均衡，让所有 P (及其 M) 尽量保持忙碌，提高 CPU 利用率。

### **Q4: Goroutine 切换为什么比线程切换快得多？**

**A:** 主要原因有：

1. **用户态 vs 内核态:** Goroutine 切换完全在用户态由 Go runtime 完成，不涉及昂贵的内核态/用户态切换；线程切换由 OS 内核调度，需要模式切换。
    
2. **保存状态少:** Goroutine 切换只需保存极少的寄存器状态（主要是程序计数器 PC 和栈指针 SP）；线程切换需要保存完整的 CPU 寄存器组、内核栈信息、内存管理上下文等。
    
3. **内存管理:** Goroutine 都在同一地址空间，切换不涉及内存页表切换；线程切换（尤其跨进程）可能需要。
    
4. **栈空间:** Goroutine 初始栈小，管理更灵活；线程栈通常较大且固定。
    

### **Q5: Go 如何处理阻塞的系统调用 (Syscall)？Sysmon 的作用是什么？**

**A:**

1. **M 阻塞:** 当 G 发起阻塞 syscall，执行它的 M 会随之陷入内核阻塞。
    
2. **P 分离可能:** 为防止 P 被该阻塞 M 长时间占用而闲置，runtime 可能会将 P 从 M 解绑（P 状态置为 _Psyscall）。
    
3. **Sysmon 介入:** 后台 sysmon 线程会监控阻塞在 syscall 里的 M。如果阻塞时间过长（如超 10ms），sysmon 会认为 M 短期内不会返回。
    
4. **P Handoff:** sysmon 会强制将 P 从该 M 解绑（状态改为 _Pidle），使其能被其他空闲或新建的 M 绑定，去执行 P 上的其他 G，保证 CPU 不被浪费。
    
5. **M 返回:** 当 M 从 syscall 返回后，它需要重新找一个 P：优先找原来的 P，其次找空闲 P，再找不到则将 G 放回 GRQ，M 自己休眠。
    

### **Q6: 什么是 g0？它有什么特殊之处和作用？**

**A:** g0 是每个 P 关联的一个特殊 Goroutine，代表**调度器本身**。

- **特殊性:** 它不执行用户代码，运行在 M 的系统栈（或专用调度栈）上，栈空间固定且较大。
    
- **作用:**
    
    - 执行调度循环：寻找并切换到下一个可运行的用户 Goroutine (g)。
        
    - 处理 Goroutine 的生命周期事件：在 G 阻塞、完成、抢占时接管控制权。
        
    - 执行 runtime 任务：如执行 defer、参与 GC（栈扫描）、处理栈增长等。
        
- **重要提示:** g0 是调度执行者，但普通 Goroutine g 的切换上下文（PC/SP）是保存在 g 自己的结构体里的，不是存在 g0 里。
    

### **Q7: Go runtime 会复用 Goroutine 吗？还需要手动实现协程池吗？**

**A:**

- **会复用:** Go runtime 内建了 Goroutine 对象的复用机制。当 Goroutine 结束时，其 G 对象会被放入本地或全局的空闲列表 (freelist)，下次创建 Goroutine 时会优先从中获取复用，减少内存分配和 GC 压力。
    
- **通常不需要手动协程池:** 因为 runtime 的高效调度和内建复用，大多数场景下直接 go func() 启动 Goroutine 是最佳实践。手动创建“协程池”的主要目的**不是**为了节省 Goroutine 创建开销，而是为了**控制并发度**（例如限制同时处理任务的 worker 数量）或进行特殊的**资源管理**。
    

### Q8: 什么是线程自旋？它在 GMP 中有什么应用？**

**A:** 线程自旋是一种**忙等待**优化技术。当一个线程（在 Go 里是 M）尝试获取一个已被占用的锁或等待某个短时条件时，它会在一个紧密循环里不断检查条件是否满足，而不是立即放弃 CPU 进入睡眠。

- **在 GMP 中的应用:**
    
    - M 尝试获取 runtime 内部的锁（如调度锁、内存分配锁）时。
        
    - M 在 P 的 LRQ、GRQ 为空时，短时间自旋等待新的 G 到来或能成功窃取到 G。
        
- **目的：** 如果等待时间非常短，自旋可以避免昂贵的线程上下文切换和唤醒延迟。但如果等待时间长，会浪费 CPU。Go runtime 中的自旋通常是**自适应**的，有次数或时间限制。
    

### **Q9: GMP 模型带来了哪些优势？**

**A:**

1. **高并发:** 轻松创建和管理成千上万的 Goroutine。
    
2. **低开销:** Goroutine 创建、切换成本远低于线程。
    
3. **高效利用多核:** 通过 GOMAXPROCS 控制 P 的数量，实现真正的并行计算。
    
4. **避免阻塞:** 通过 netpoller 处理非阻塞 I/O，通过 sysmon 和 P handoff 机制处理阻塞 syscall，最大限度减少 M 因等待而被阻塞的影响。
    
5. **负载均衡:** 工作窃取机制确保 CPU 资源被充分利用。
    
6. **资源节约:** 复用 OS 线程 (M) 和 Goroutine 对象 (G)。
### **Q10: Goroutine 的栈是固定大小的吗？如果不是，它是如何管理的？**

**A:** 不是固定的。Goroutine 启动时拥有一个很小的初始栈（通常 2KB）。Go 使用**连续栈 (Contiguous Stack)** 机制来管理它。这意味着：

1. **动态增长:** 当函数调用需要的空间超过当前栈的剩余容量时，栈会自动扩容。
    
2. **连续性:** 在任何时刻，一个 Goroutine 的活动栈都存储在一块**连续**的内存区域中。
    
3. **扩容方式:** 扩容时，Go runtime 会分配一块新的、更大的连续内存（通常是旧栈两倍），将旧栈内容**完整拷贝**到新栈，**调整**旧栈内的指针指向新地址，然后**释放**旧栈内存。
    
4. **栈收缩:** GC 期间，如果发现栈长期使用率很低，也可能进行栈收缩，释放多余内存。
    

### **Q11: 什么是栈扩容？这个过程的开销如何？在什么情况下会频繁发生？**

**A:**

- **过程:** 栈扩容是 Goroutine 栈空间不足时，runtime 自动分配更大栈、拷贝旧内容、调整指针、释放旧栈的过程。它由函数入口处的栈检查（Stack Check）失败后调用的 runtime.morestack 触发。
    
- **开销:** 栈扩容**不是免费的**，其开销主要来自：
    
    - **内存拷贝 (memcpy):** 主要成本，拷贝量与旧栈大小成正比。
        
    - 内存分配、指针调整、上下文切换（到g0再回来）也有开销。
        
    - 这会导致触发扩容的函数调用产生一次**延迟**。
        
- **频繁发生场景:**
    
    - **无限/过深的递归调用:** 最常见的原因。
        
    - **在栈上分配了非常大的对象/数组。**
        
    - **极深的函数调用链。**
        
    - **特定模式下的“热分裂”遗留问题（理论上连续栈已解决，但极端深且小的调用仍可能触发多次扩容）。**
        
    - 频繁发生通常表示代码可能需要优化，应通过 profiling 确认。
        

 

### **Q18: 什么是 Cgo？在哪些业务场景下可能会用到它？**

**A:** Cgo 是 Go 语言调用 C 代码（反之亦然）的机制。在业务场景中，常见用途包括：

1. **使用 C 库的数据库驱动:** 如 go-sqlite3 (SQLite), Oracle OCI 驱动。
    
2. **集成现有 C/C++ 核心库/SDK:** 调用公司内部遗留的 C/C++ 业务逻辑、算法库，或第三方提供的只有 C/C++ 接口的 SDK。
    
3. **特定领域库:** 业务需要 GIS (GEOS/GDAL)、某些科学计算、特定协议解析等只有成熟 C/C++ 实现的库。
    
4. **安全/合规:** 需要调用 OpenSSL (如 FIPS 模式) 或与 HSM (硬件安全模块) 交互。
    

- **注意:** 使用 Cgo 会增加构建复杂性、部署依赖、带来性能开销和内存管理挑战，应优先寻找纯 Go 解决方案。

## go 内存管理

### go内存管理核心组件mheap mcentral mcache mspan
![[svg.svg|925]]


1. **`mcache` (每个工人的私人工具箱):** 每个处理 Go 程序任务的“工人”（称为 `P`，Processor）都有自己的一个小型、快速的缓存。存取自己工具箱里的东西最快，不需要和别人商量（无锁）。
2. **`mcentral` (部门共享工具柜):** 有很多个工具柜，每个柜子只存放特定 _种类/尺寸_ 的物品（Size Class）。同一个部门（所有 `P`）的工人都可以来这里取，但一次只能一个人取/放（需要加锁）。
3. **`mheap` (中央大仓库):** 这是所有部门共享的、最大的仓库。管理着大量的、成块的“空地”（内存页 Pages）。从这里调拨资源比较慢，需要和仓库主管协调（需要加锁）。
4. **OS (外部供应商):** 如果中央大仓库也没货了，就只能向操作系统这个“外部供应商”订购更大块的“土地”（通过 `mmap` 等系统调用）。这是最慢的方式。

---

### 3.3 小对象分配 (<= 32KB) —— 拿小零件

想象你要拿一个小螺丝（一个小于等于 32KB 的内存块）。

**流程图（文字模拟）：**

```
你要拿小螺丝 (请求内存)
  │
  ▼
1. 确定螺丝规格 (计算 Size Class: 把你需要的大小，归到最近的标准规格里)
  │
  ▼
2. 查看【我的工具箱 mcache】里，对应规格的盒子(mspan)还有没有?
  │   │
  │   ├─> 有空位? (allocation bitmap) -> 太好了! 直接拿走 (标记已用, 返回地址) 【最快! 无锁】
  │   │
  │   └─> 没有空位 / 没有这种规格的盒子?
  │          │
  │          ▼
  │       3. 去【部门工具柜 mcentral】(对应规格的) 申请一整盒新的螺丝 (mspan)
  │          │   │
  │          │   ├─> 工具柜里有现成的盒子? (加锁访问) -> 拿到盒子，放进【我的工具箱 mcache】-> 回到第 2 步
  │          │   │
  │          │   └─> 工具柜里也没有了?
  │          │          │
  │          │          ▼
  │          │       4. 工具柜管理员去【中央大仓库 mheap】申请一块空地 (Pages) 来装新的螺丝盒
  │          │          │   │
  │          │          │   ├─> 仓库里有合适的空地? (加锁访问) -> 拿到空地，做成新的螺丝盒(mspan)，交给【部门工具柜 mcentral】-> 【部门工具柜】再给我一盒 -> 回到第 2 步
  │          │          │   │
  │          │          │   └─> 仓库里也没有足够大的连续空地?
  │          │          │          │
  │          │          │          ▼
  │          │          │       5. 仓库管理员向【外部供应商 OS】订购一大块新土地 (mmap) 【最慢!】
  │          │          │          │ -> 新土地入库【中央大仓库 mheap】-> 回到第 4 步
  │          │          │
  │          ▼          ▼
  │       (拿到螺丝后)
  ▼       6. 这颗螺丝需要擦干净吗? (needzero 标志 / 明确要求) -> 如果需要，擦干净 (内存清零)
  │
  ▼
递给你干净的螺丝 (返回内存指针)
```

**简单说：**

1. **先看自己手边 (`mcache`) 有没有？** 这是最快的方式，不用跟任何人打交道。
2. **手边没有，去部门仓库 (`mcentral`) 领一整盒。** 需要排队（加锁），但领回来后又能快速用了。
3. **部门仓库也没有，部门管理员去中央仓库 (`mheap`) 申请原料。** 更慢，也要排队（加锁）。
4. **中央仓库也没原料了，只能向外面 (`OS`) 订购。** 这是最慢的兜底方案。
5. **最后，按需把拿到的东西擦干净（清零）。**

这种层层递进的方式，确保了最高频的小对象分配尽可能发生在最快的 `mcache` 层面，大大减少了需要加锁和访问慢速资源的次数。

---

### 3.4 大对象分配 (> 32KB) —— 搬大机器

想象你要搬一台大机器（一个大于 32KB 的内存块）。这种大家伙，你的小工具箱和部门工具柜都放不下。

**流程图（文字模拟）：**

```
你要搬大机器 (请求内存 > 32KB)
  │
  ▼
1. 计算需要多大的场地 (向上取整到 8KB 的倍数，即多少个 Page)
  │
  ▼
2. 直接去【中央大仓库 mheap】申请这么大的连续空地
  │   │
  │   ├─> 仓库里有足够大的连续空地? (加锁访问) -> 分配空地，用栅栏围起来(创建 mspan 管理) -> 跳到第 4 步
  │   │
  │   └─> 仓库里没有这么大的连续空地?
  │          │
  │          ▼
  │       3. 仓库管理员向【外部供应商 OS】订购所需大小的新土地 (mmap) 【慢!】
  │          │ -> 新土地入库【中央大仓库 mheap】-> 回到第 2 步 (重新尝试在仓库分配)
  │
  ▼
3. 把分配到的场地彻底打扫干净 (内存清零) 【大对象总是清零】
  │
  ▼
把场地的入口指给你 (返回内存指针，即 mspan 起始地址)
```

**简单说：**

1. **直接跳过** `mcache` 和 `mcentral`，因为它们处理不了这么大的东西。
2. **直接去中央大仓库 (`mheap`)** 申请一块足够大的连续空间。需要排队（加锁）。
3. **仓库空间不够，就向外面 (`OS`) 订购。**
4. **拿到空间后，一定打扫干净（清零）** 再交给你用。

这个流程更直接，因为它知道小缓存和共享柜处理不了大件，索性直接去能处理的地方。

---

### 栈管理、栈扩容、内存分配细节

### **Q10: Goroutine 的栈是固定大小的吗？如果不是，它是如何管理的？**

**A:** 不是固定的。Goroutine 启动时拥有一个很小的初始栈（通常 2KB）。Go 使用**连续栈 (Contiguous Stack)** 机制来管理它。这意味着：

1. **动态增长:** 当函数调用需要的空间超过当前栈的剩余容量时，栈会自动扩容。
    
2. **连续性:** 在任何时刻，一个 Goroutine 的活动栈都存储在一块**连续**的内存区域中。
    
3. **扩容方式:** 扩容时，Go runtime 会分配一块新的、更大的连续内存（通常是旧栈两倍），将旧栈内容**完整拷贝**到新栈，**调整**旧栈内的指针指向新地址，然后**释放**旧栈内存。
    
4. **栈收缩:** GC 期间，如果发现栈长期使用率很低，也可能进行栈收缩，释放多余内存。
    

### **Q11: 什么是栈扩容？这个过程的开销如何？在什么情况下会频繁发生？**

**A:**

- **过程:** 栈扩容是 Goroutine 栈空间不足时，runtime 自动分配更大栈、拷贝旧内容、调整指针、释放旧栈的过程。它由函数入口处的栈检查（Stack Check）失败后调用的 runtime.morestack 触发。
    
- **开销:** 栈扩容**不是免费的**，其开销主要来自：
    
    - **内存拷贝 (memcpy):** 主要成本，拷贝量与旧栈大小成正比。
        
    - 内存分配、指针调整、上下文切换（到g0再回来）也有开销。
        
    - 这会导致触发扩容的函数调用产生一次**延迟**。
        
- **频繁发生场景:**
    
    - **无限/过深的递归调用:** 最常见的原因。
        
    - **在栈上分配了非常大的对象/数组。**
        
    - **极深的函数调用链。**
        
    - **特定模式下的“热分裂”遗留问题（理论上连续栈已解决，但极端深且小的调用仍可能触发多次扩容）。**
        
    - 频繁发生通常表示代码可能需要优化，应通过 profiling 确认


### Go 对小于 16 字节且不包含指针的对象有什么特殊处理吗？
1. **垃圾回收 (GC)**:
    
    - **无指针对象扫描**: 这是最重要的优化。如果 Go 的编译器和运行时确定一个类型不包含任何指针（无论是直接的还是嵌套的），它会在分配该类型的对象时，在对应的内存元信息（例如 gcbits 位图）中标记该内存区域为“无指针”。
        
    - **跳过扫描**: 在 GC 的标记（Mark）阶段，当扫描器遇到被标记为“无指针”的内存块时，它会完全跳过扫描该内存块的内容。扫描器只需要知道这个对象的大小，然后直接跳到下一个对象。这大大减少了 GC 的扫描工作量，特别是当存在大量此类小对象时。对于包含指针的对象，GC 必须仔细检查其内容以查找并跟踪其他活动对象的引用。
        
    - **大小无关**: 这个“无指针”优化本身与对象大小（是否小于 16 字节）没有直接关系，但它对所有不含指针的对象都适用。然而，小对象通常数量更多，因此这种优化的累积效应可能更显著。
        
2. **内存分配**:
    
    - **微小对象分配器 (Tiny Allocator)**: Go 的内存分配器对非常小的对象（通常是 <= 16 字节且无指针的对象）有特殊的优化。这些对象可能会被分配到一个称为“tiny block”的特殊区域，或者使用特定的 size class 进行管理。
        
    - **Size Classes**: Go 的分配器使用预定义的 size classes 来管理不同大小的内存块。小于 16 字节的对象会落入最小的几个 size class 中。分配器会为这些 size class 维护专门的 mspan（内存管理单元），并通常从线程本地缓存 (mcache) 中快速分配，减少了锁竞争和分配开销。
        
    - **无指针优化**: 结合 GC 的无指针标记，分配器可以更有效地管理这些小块内存，因为知道它们不需要被 GC 扫描。
        
3. **栈分配 (Escape Analysis)**:
    
    - **更易于栈分配**: Go 的编译器会进行逃逸分析（Escape Analysis），尝试将对象的分配从堆（Heap）移到栈（Stack）上。栈分配非常快，并且不需要 GC 来管理。
        
    - **小尺寸优势**: 小对象（如小于 16 字节）由于复制成本低，更有可能被编译器判断为适合在栈上分配（如果它们的生命周期没有逃逸出当前函数）。
        
    - **无指针简化**: 虽然不是决定性因素，但不包含指针的简单结构体使得逃逸分析更容易进行。
        
4. **值传递和复制**:
    
    - **低成本复制**: 对于这么小的对象，在函数调用时按值传递（复制整个对象）的开销非常低。这通常比传递指针（需要解引用，可能导致缓存未命中）然后访问堆上数据的开销还要小，并且避免了潜在的堆分配。


### 你对 Go 的内存管理机制了解多少？
好的，面试官。嗯... 我的理解是，Go 语言的内存管理最大的特点就是它**自带了垃圾回收（GC）机制**，开发者基本上不需要手动去申请和释放内存，这一点跟 C/C++ 很不一样，可以大大减少内存泄漏的风险，也减轻了开发者的心智负担。

Go 的内存管理主要是围绕 **自动内存分配** 和 **自动垃圾回收** 这两个核心来的。

- **内存分配方面**，Go 为了提高效率，自己管理了一个**内存池**。它会向操作系统申请一大块内存，然后自己切分成不同大小的 `span` (内存块) 来管理。对于不同大小的对象，它有不同的分配策略。比如小对象，它会倾向于从一个叫做 `mcache` 的 per-P（处理器）的本地缓存里分配，这样可以减少锁的竞争，速度很快。如果没有或者对象比较大，可能就会去 `mcentral` (中心缓存) 或者直接去 `mheap` (堆) 上分配了。
- **垃圾回收方面**，Go 现在主要使用的是**并发的三色标记清除法** (Concurrent Mark and Sweep)。这个 GC 最大的优点就是它大部分工作是**和用户 Goroutine 并发执行**的，只有很短的 STW (Stop The World) 时间，所以对程序造成的卡顿影响很小，这也是 Go 适合做高并发服务的一个重要原因。

### 你刚才提到了“并发三色标记清除法”，能稍微展开讲讲这个 GC 的过程吗？
**候选人:** 当然可以。简单来说，三色标记法就是把内存中的对象分成三类：

1. **白色对象**：代表可能是垃圾，待检查的对象。初始时所有对象都是白色的。
2. **灰色对象**：代表自身是存活的，但是它引用的对象还没检查完。GC 会从根对象（比如全局变量、执行栈上的变量）开始，把它们标记为灰色。
3. **黑色对象**：代表自身是存活的，并且它引用的所有对象也都检查过了（或者已经被标记为灰色了）。

GC 的主要流程就是：

1. **开始标记 (Mark Setup)**：会有一个非常短暂的 STW，主要是做一些准备工作，比如开启写屏障 (Write Barrier)。写屏障很重要，它就像一个监控，能在标记过程中，如果用户 Goroutine 修改了对象间的引用关系（比如一个黑色对象指向了一个白色对象），它能保证这个白色对象不会被错误地回收掉，通常是把它重新标记为灰色。
2. **并发标记 (Marking)**：这是 GC 最耗时的阶段，但它是和用户 Goroutine 并发执行的。GC 会不断地从灰色对象集合里拿出对象，把它引用的所有白色对象都标记为灰色，然后把自己标记为黑色。这个过程一直持续，直到没有灰色对象为止。
3. **标记结束 (Mark Termination)**：也会有一个 STW，时间也比较短。主要是完成标记工作，关闭写屏障。
4. **并发清扫 (Sweeping)**：这个阶段也是并发的。GC 会遍历所有的内存块 (`mspan`)，把所有白色对象（也就是垃圾）占用的内存回收掉，方便后续分配。

哦对了，这个过程中，写屏障 (Write Barrier) 和辅助 GC (Mutator Assist) 是保证并发正确性和效率的关键技术。写屏障保证不错杀，辅助 GC 会让分配内存的用户 Goroutine 帮忙做一些标记工作，防止 GC 进度跟不上分配速度。

### 除了 GC 回收，在内存分配这块，Go 是怎么区分对待小对象和大对象的呢？它们分配的路径有什么不同？
**候选人:** 嗯，这个处理方式是不一样的。Go 内部会对要分配的内存大小做一个判断。

- **对于小对象**（一般是小于等于 32KB 的），Go 会有一套精细化的管理策略。它会把内存页（通常是 8KB）切割成很多个固定大小的小块（`object`），然后用 `mspan` 来管理这些同样大小的小块。分配的时候，会先尝试从当前 Goroutine 所在的 P 的本地缓存 `mcache` 里找对应的 `mspan`，这里分配几乎没有锁，非常快。如果 `mcache` 里没有合适的 `mspan`，就会去 `mcentral` 里加锁获取一个，`mcentral` 是所有 P 共享的，它会管理着各种大小规格的 `mspan` 列表。如果 `mcentral` 也没有，才会向 `mheap` 申请内存页，切割成 `mspan` 再分配。
- **对于大对象**（大于 32KB 的），Go 就不会走 `mcache` 和 `mcentral` 这套复杂的缓存机制了，它会直接从 `mheap` 上分配足够数量的连续内存页。因为大对象分配的频率相对较低，而且每次分配的内存量大，直接走 `mheap` 更简单高效。

总的来说，就是用缓存和分级策略来优化小对象的分配速度和内存碎片问题，大对象则直接向堆申请。

### 我们平时写的变量，比如函数里的局部变量，Go 是怎么决定把它放在栈 (stack) 上还是堆 (heap) 上呢？是开发者指定的吗？
这个不是开发者显式指定的，Go 编译器会自动进行**逃逸分析 (Escape Analysis)** 来决定。

简单来说，编译期，编译器会分析一个变量的作用域和生命周期。

- 如果一个变量只在函数内部使用，它的生命周期明确，并且函数返回后就不再需要了，那么它通常会被分配在**栈**上。栈内存分配和回收非常快，只需要移动栈指针就行，开销很小。
    
- 但是，如果编译器发现这个变量的生命周期可能会超过这个函数本身，比如：
    
    - 这个变量的**指针被函数返回**了。
    - 这个变量被**闭包引用**了，并且这个闭包在函数返回后还可能被调用。
    - 这个变量被**发送到了 channel** 里（因为不知道接收方什么时候处理）。
    - 变量太大，超过了栈的限制（虽然比较少见）。
    - 或者被 `slice` 或 `map` 的 `value` 间接引用，并且 `slice` 或 `map` 本身逃逸了。
    
    只要出现类似这些情况，编译器就认为这个变量**“逃逸”**了，必须把它分配在**堆**上，这样即使函数返回了，它指向的内存也不会被立刻回收，可以通过 GC 来管理它的生命周期。


## channel
![[Pasted image 20250419214222.png]]
![[Pasted image 20250419215703.png]]![[Pasted image 20250419215707.png]]

---


### 介绍一下 Golang 中的 Channel 是什么

**候选人（我）**：面试官你好！Golang 的 Channel 是一种用于在不同 Goroutine 之间进行通信和同步的管道（Pipe）。你可以把它想象成一个类型安全的队列，数据可以从一端被发送进去（`<-` 操作符用于发送），然后从另一端被接收出来（`<-` 操作符也用于接收）。

Channel 的主要目的是解决并发编程中的两个核心问题：

1. **Goroutine 间的通信**：让不同的 Goroutine 可以安全地交换数据，避免了传统共享内存+锁（Mutex）模式下可能出现的复杂性和潜在的数据竞争（Race Condition）问题。Go 提倡 "不要通过共享内存来通信，而要通过通信来共享内存"。
2. **Goroutine 间的同步**：Channel 的发送和接收操作本身具有阻塞性（对于某些类型的 Channel），这可以被用来协调 Goroutine 的执行顺序，比如等待一个 Goroutine 完成任务后再继续执行。

### 讲讲 unbuffered channel 和 buffered channel 的区别

**候选人**：当然。Channel 主要分为两种：

1. **Unbuffered Channel (无缓冲通道)**：
    
    - 创建方式：`make(chan T)`，其中 T 是通道传输的数据类型，容量为 0。
    - **特点**：发送操作 (`ch <- data`) 会阻塞，直到有另一个 Goroutine 准备好从该 Channel 接收数据 (`<- ch`)。同样，接收操作也会阻塞，直到有另一个 Goroutine 向该 Channel 发送数据。这种方式也被称为同步通道，因为它强制发送和接收操作同步发生。
    - **使用场景**：
        - 需要强同步保证的场景，确保发送方知道接收方已经准备好接收，或者接收方知道发送方已经发送了数据。
        - 作为信号量使用，例如通知任务完成。发送一个值，接收方接收到即表示信号到达。
2. **Buffered Channel (有缓冲通道)**：
    
    - 创建方式：`make(chan T, capacity)`，其中 `capacity > 0`。
    - **特点**：发送操作只有在缓冲区满时才会阻塞。接收操作只有在缓冲区空时才会阻塞。只要缓冲区未满，发送操作就可以立即完成（异步）；只要缓冲区不空，接收操作就可以立即完成。
    - **使用场景**：
        - 解耦生产者和消费者：允许生产者和消费者以不同的速率工作，缓冲区可以作为临时的存储。
        - 提高吞吐量：在某些情况下，允许一定程度的异步可以减少 Goroutine 阻塞等待的时间。
        - 实现类似信号量或限制并发数的模式：例如，创建一个容量为 N 的 buffered channel，工作 Goroutine 在开始工作前向 channel 发送一个值（获取令牌），工作结束后再接收一个值（释放令牌）。

### 那么，向一个已经关闭的 Channel 发送数据会发生什么？从一个已经关闭的 Channel 接收数据呢？为什么需要关闭 Channel？

**候选人**：操作已关闭的 Channel 会有以下行为：

1. **向已关闭的 Channel 发送数据**：会导致程序 panic。这是因为关闭 Channel 意味着不会再有新的数据进入，继续发送违反了这个约定。
2. **从已关闭的 Channel 接收数据**：
    - 如果 Channel 的缓冲区中还有数据，接收操作会成功，依次返回缓冲区中的值。
    - 如果 Channel 的缓冲区已经为空，接收操作会立即返回，得到的是该 Channel 元素类型的零值（例如，`int` 类型是 `0`，`string` 类型是 `""`，指针是 `nil`）。
    - 为了区分接收到的是正常值还是因为 Channel 关闭而得到的零值，可以使用多重返回值的方式接收：`value, ok := <- ch`。如果 `ok` 为 `true`，表示成功接收到了一个有效值 `value`；如果 `ok` 为 `false`，表示 Channel 已经被关闭且缓冲区为空，此时 `value` 是零值。

为什么要关闭 Channel：

关闭 Channel 主要用于通知接收方：不会再有新的数据发送到这个 Channel 了。这对于接收方使用 range 循环来处理 Channel 数据尤为重要。如果没有关闭 Channel，range 循环会一直阻塞等待新的数据，导致死锁。当 Channel 被关闭后，range 循环会在读取完所有缓冲数据后自动结束。

### **面试官**：那对一个 nil channel 进行读写操作会发生什么？

**候选人**：对 `nil` channel（即未初始化的 channel 或被赋值为 `nil` 的 channel）进行操作会导致：

- **向 `nil` channel 发送数据**：会永久阻塞当前 Goroutine。
- **从 `nil` channel 接收数据**：会永久阻塞当前 Goroutine。
- **关闭 `nil` channel**：会导致程序 panic。

`nil` channel 在 `select` 语句中有一个特殊的用途：可以用来禁用 `select` 中的某个 `case` 分支。如果 `select` 中的某个 case 涉及的 channel 是 `nil`，那么这个 case 将永远不会被选中。

**面试官**：提到 `select`，你能解释一下 `select` 语句的作用以及它是如何处理多个 Channel 操作的吗？

**候选人**：`select` 语句是 Go 语言中处理异步 I/O 或多路 Channel 通信的核心机制。它类似于 `switch` 语句，但其 `case` 后面跟的是 Channel 的发送或接收操作。

`select` 的主要作用是：**同时监听多个 Channel 操作，并在其中一个可以进行（非阻塞）时执行相应的 case 代码块。**

其行为特点如下：

1. **监听**：`select` 会监听所有 `case` 中涉及的 Channel 操作（发送或接收）。
2. **选择**：
    - 如果**只有一个** case 的 Channel 操作可以立即进行（即不会阻塞），则执行该 case。
    - 如果**有多个** case 的 Channel 操作都可以立即进行，`select` 会**随机选择**其中一个执行。这是为了防止饥饿，保证公平性。
    - 如果**所有** case 的 Channel 操作都需要阻塞，`select` 的行为取决于是否有 `default` 子句：
        - **有 `default` 子句**：执行 `default` 子句，`select` 语句不会阻塞。这常用于实现非阻塞的 Channel 操作检查。
        - **没有 `default` 子句**：`select` 语句会阻塞，直到其中一个 Channel 操作变得可以进行为止。
3. **`nil` channel 的处理**：如刚才提到的，如果 `select` 的某个 case 涉及的操作是针对 `nil` channel 的，那么这个 case 将永远不会被选中。

`select` 广泛应用于：超时控制、多任务协调、退出信号处理等场景。

### 能举例说明一下可能导致死锁（Deadlock）的情况吗？

**候选人**：使用 Channel 时确实有一些常见的陷阱和需要注意的地方：

1. **死锁 (Deadlock)**：这是最常见的问题。当程序中所有的 Goroutine 都被阻塞，无法继续执行时，就会发生死锁。常见导致死锁的情况包括：
    
    - **主 Goroutine 等待子 Goroutine，但子 Goroutine 却在等待主 Goroutine 或其他已阻塞的 Goroutine**。
    - **向 unbuffered channel 发送数据，但没有接收者**：`ch := make(chan int); ch <- 1` (在单个 Goroutine 中执行，会死锁)。
    - **从 unbuffered channel 接收数据，但没有发送者**：`ch := make(chan int); <- ch` (在单个 Goroutine 中执行，会死锁)。
    - **向已满的 buffered channel 发送数据**。
    - **从已空的 buffered channel 接收数据**。
    - **循环等待**：Goroutine A 等待 Goroutine B，Goroutine B 等待 Goroutine A。
    - **`range` 一个未关闭的 Channel**：如果所有发送者都已退出，但 Channel 未关闭，`range` 循环会永久阻塞等待。
2. **Panic**：
    
    - 向已关闭的 Channel 发送数据。
    - 关闭一个已经关闭的 Channel。
    - 关闭一个 `nil` channel。
3. **资源泄露 (Goroutine Leak)**：如果 Goroutine 因为等待 Channel 操作（如从 Channel 接收或向 Channel 发送）而被永久阻塞，并且永远没有机会解除阻塞（例如，对应的发送者或接收者已经退出，或者 Channel 永远不会被关闭），那么这个 Goroutine 就泄露了，它占用的资源无法释放。
    
4. **误用 `nil` channel**：忘记初始化 Channel（使其为 `nil`）然后进行读写，导致永久阻塞。
    

**避免策略**：

- 仔细设计 Goroutine 间的通信模式，确保发送和接收操作能够匹配。
- 对于需要结束的 Channel，发送方负责关闭它，并且只关闭一次。
- 在可能阻塞的地方使用 `select` 配合 `default` 或超时机制。
- 使用 `sync.WaitGroup` 等待一组 Goroutine 完成，而不是仅仅依赖 Channel 通信来判断。
- 注意 `range` Channel 的退出条件，确保 Channel 会被关闭。

**面试官**：非常棒！你对 Channel 的理解很深入，也考虑到了很多实践中的细节。今天的面试就到这里，感谢你的参与。

**候选人**：谢谢面试官！我也很高兴能和您交流。

---


## 计算机网络
### HTTP 常见的状态码有哪些？

2xx 开头表示成功，比如 200 OK。
3xx 开头表示重定向，比如 301 永久搬家，304 东西没变用缓存。
4xx 开头表示客户端请求有问题，比如 404 Not Found 找不到，403 Forbidden 不让看。
5xx 开头表示服务器那边出问题了，比如 500 Internal Server Error 服务器内部出错。
HTTP 常见字段有哪些？

就是请求和响应头里带的一些说明信息，像 Host 说明访问哪个网站，Content-Type 说明内容格式，Cookie 用来带用户登录状态之类的信息，Cache-Control 指示怎么缓存。
### GET 和 POST 有什么区别？

通常 GET 用来拿数据，参数放 URL 里；POST 用来交数据，参数通常放在请求体（body）里。GET 一般不改服务器数据，POST 会改。GET 请求能缓存，POST 一般不行。
GET 和 POST 方法都是安全和幂等的吗？

按规矩说，GET 应该是安全（不改变服务器数据）且幂等（请求一次和多次效果一样）的。POST 通常两者都不是。但实际开发中不一定严格遵守。
### HTTP 缓存有哪些实现方式？

主要就两种：强制缓存和协商缓存。
### 什么是强制缓存？

就是浏览器看自己存的这份缓存还没到期（根据 Cache-Control 或 Expires），就直接用了，不跟服务器打招呼。
### 什么是协商缓存？

就是强制缓存过期了，浏览器带点儿上次缓存的信息（像 ETag 版本号或 Last-Modified 时间）去问服务器：“我这份旧的还能用吗？” 服务器对比一下，没变就回个 304，让用旧的；变了就回 200 带上新的。
### HTTP/1.1 的优点有哪些？

主要优点是简单，基于文本容易懂；而且通用，用得非常广泛。
### HTTP/1.1 的缺点有哪些？

缺点主要是：性能上有队头阻塞 (Head-of-Line Blocking) 问题，意思是在同一个 TCP 连接上，响应必须按请求顺序返回，所以前一个响应处理慢或异常了就会阻塞后续所有响应的发送和接收，导致连接效率低下；此外还有明文传输不安全；请求头部信息冗余；协议无状态管理起来也比较麻烦。
HTTP/1.1 的性能如何？

性能比 1.0 强，主要是靠长连接 (Keep-Alive)，这个机制指的是在一个 TCP 连接建立后可以传输多个 HTTP 请求和响应，避免了像 HTTP/1.0 那样每个请求都重新建立 TCP 连接（三次握手）的开销。但它的主要性能瓶颈还是队头阻塞（前面已解释），这限制了单个连接上的并发处理能力，所以在复杂页面场景下性能一般。
### HTTP 与 HTTPS 有哪些区别？

HTTPS 就是给 HTTP 加了层 SSL/TLS 安全协议，传输内容是加密的，更安全。用的端口不一样（HTTP 80, HTTPS 443），HTTPS 服务器需要证书。
### HTTPS 解决了 HTTP 的哪些问题？

解决了 HTTP 明文传输被窃听、被篡改、服务器被假冒这三大安全风险。
HTTPS 是如何建立连接的？其间交互了什么？

比 HTTP 多一步 TLS 握手过程。逻辑上是：双方先确认对方身份（主要是客户端验证服务器证书），然后协商确定本次通信使用的加密套件，最后安全地生成和交换用于加密应用数据的会话密钥。
HTTPS 的应用数据是如何保证完整性的？

通过消息认证码 (MAC) 机制。发送数据时，会根据数据内容和双方共享的会话密钥算出一个 MAC 值，附加在加密数据旁。接收方解密后，用同样方法计算 MAC，与收到的 MAC 比对，一致则说明数据未被篡改。
### HTTPS 一定安全可靠吗？

协议本身设计是安全的。但实际安全性依赖于正确的证书验证（比如用户不能忽略浏览器警告）和客户端环境的安全（比如操作系统信任的根证书列表未被污染）。否则，仍可能遭受中间人攻击。
### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

最主要的提升是默认启用了长连接 (Keep-Alive)，也就是可以用一个 TCP 连接处理多个 HTTP 请求，省去了频繁建立和断开 TCP 连接（三次握手）的开销。
### HTTP/2 做了什么优化？

核心是多路复用，允许在一个 TCP 连接上并行、交错地处理多个请求/响应流，解决了 HTTP/1.1 应用层的队头阻塞问题。还有头部压缩 (HPACK)、二进制传输、服务器推送等也提升了效率。
### HTTP/3 做了哪些优化？

最大改变是底层换用了基于 UDP 的 QUIC 协议。因为 HTTP/2 虽解决了应用层阻塞，但 TCP 协议本身为了保证数据按序到达，在网络丢包时会暂停所有流的数据交付，这叫 TCP 层的队头阻塞。QUIC 在 UDP 之上为每个流独立管理可靠性，一个流的丢包不影响其他流，因此彻底解决了队头阻塞问题。而且 QUIC 连接建立更快，还能支持连接迁移（切换网络时保持连接）

### RSA vs ECDHE 握手区别（精简版）：
- **RSA 交换：**
    
    - 客户端**生成**一个秘密（预主密钥）。
    - 用服务器证书里的**长期公钥加密**这个秘密，发给服务器。
    - 服务器用自己的**长期私钥解密**得到秘密。
    - **缺点：** 没有**前向安全性**（服务器私钥丢了，历史通信可能被解密）。
- **ECDHE 交换：**
    
    - 客户端和服务器都**临时生成**密钥对。
    - 双方交换**临时公钥**（服务器会用长期私钥**签名**自己的临时公钥信息，证明身份）。
    - 双方**各自独立**用自己的临时私钥和对方的临时公钥，通过算法**算出**同一个秘密（预主密钥），这个秘密**不直接在网络上传输**。
    - **优点：** 有**前向安全性**（服务器私钥丢了，不影响历史通信安全）。