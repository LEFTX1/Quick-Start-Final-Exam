![[黑白整齐简历模板 (2).pdf]]


# 技术描述部分
## 并发模型
###  你理解的 Goroutine 是什么？
Goroutine 是 Go 语言实现的轻量级用户态线程。相比操作系统线程，Goroutine 的创建、销毁和切换成本都极低。这是因为他的初始栈空间开销很小，并且基于用户态的 GMP 模型调度，避免了用户态与内核态的转换开销。核心优势就是轻量、高效。
### 谈 Channel 在 Go 并发编程中扮演的角色吗？
Channel 是 Go 语言中Goroutine之间通信和同步的主要机制，它遵循 CSP模型，强调通过通信来共享内存。一个 Channel 在底层可以看作是一个包含了**数据缓冲区**（对于有缓冲 Channel）、**等待发送的 Goroutine 队列**、**等待接收的 Goroutine 队列**以及一个**互斥锁 (mutex)** 的数据结构。
#### **无缓冲 (Unbuffered) 和有缓冲 (Buffered) Channel**:
**无缓冲 Channel** 类似一个**握手模型**，发送和接受操作只有再两边都准备好的时候正常传送数据，单发面的发送和接受都会阻塞住，用于需要**强同步的场景**。
**有缓冲 Channel** 
- 特点：发送操作只有在缓冲区满时才会阻塞；接收操作只有在缓冲区空时才会阻塞。它允许发送和接收操作在一定程度上解耦，起到一个缓冲队列的作用。
- - 使用场景：希望解耦生产者和消费者，允许它们以不同的速率工作，或者需要缓冲一批数据时。例如，任务队列、限制并发数（利用 Channel 容量）等。
### 为什么 Go 语言还要引入 Context 包呢？
![[Pasted image 20250415194100.png]]
Context主要使用于 **调控协程之间的生命周期联动和传递元数据** 的问题。context接口有四种基本实现，分别是**空的backgroundcontext，带取消功能的cancelcontext以及带超时取消功能的timeercontext还有携带元数据value的valuecontext**,他们都可以调用四种派生方法来创建对应的子context形成一个**context树状结构。**

![[context树组成图示.svg|725]]

![[context树双向连接.svg]]

![[cancel向下传播.svg|600]]
### channel 的 csp模型是什么？
csp模型强调**通过通信来共享内存** ，具体来说就是多个并发实体Goroutine之间应该是相互独立的，它们之间的交互应该通过 Channel 来进行而不是直接访问彼此的内存数据。

### 为什么 Channel 本身就是并发安全的呢？Go 是如何保证这一点的？
Channel操作**内部都自带了同步机制**，通过内部锁来保护 Channel 的内部状态。

### 详细说说 Context 的取消信号是如何在 Goroutine 之间传递的吗？
context内部有一个map结构来储存从他派生出来的子context，从而形成父子结构的树状结果。当一个 Context 被取消时 ，**它会遍历所有它的子 Context， 向下传递去触发它们的取消逻辑**, 也就是**关闭 (close) 那个标志着context存活信息的只读channel，这个只读 Channel**由 Done() 方法返回。读取这个channel 会因为channel无数据而阻塞，但当channel关闭后会读取到零值，也就是一个空结构体，那么使用select语句监听这个channel的case语句就会执行下去，而这一行case语句就是我们处理context取消之后的操作。

#### example：
``` Go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"
)

// simulateDBQuery 模拟一个耗时的数据库查询
// 它接收一个 context，并会监听 ctx.Done() 来响应取消信号
func simulateDBQuery(ctx context.Context) (string, error) {
	// 设定这个模拟查询需要 2 秒钟
	queryDuration := 2 * time.Second
	log.Println("Worker: Starting simulated database query...")

	// 使用 select 同时等待查询完成 或 Context 被取消
	select {
	case <-time.After(queryDuration):
		// 模拟查询完成
		log.Println("Worker: Database query finished successfully.")
		return "Query Result Data", nil // 成功返回结果

	case <-ctx.Done():
		// Context 被取消了（可能是超时，也可能是客户端断开连接等）
		errMsg := fmt.Sprintf("Worker: Database query cancelled: %v", ctx.Err())
		log.Println(errMsg)
		return "", ctx.Err() // 返回 Context 的错误 (context.DeadlineExceeded 或 context.Canceled)
	}
}

// dataHandler 是处理 /data 请求的 HTTP Handler
func dataHandler(w http.ResponseWriter, r *http.Request) {
	// 1. 获取请求自带的 Context (net/http 会自动处理客户端断开连接等情况)
	baseCtx := r.Context()
	log.Printf("Handler: Received request for %s\n", r.URL.Path)

	// 2. 设置此请求处理的总超时时间为 1 秒
	//    我们从请求的 Context 派生出一个带超时的子 Context
	ctx, cancel := context.WithTimeout(baseCtx, 1*time.Second)
	//    defer cancel() 是好习惯，确保相关资源能被释放，即使我们不主动调用它
	//    (在超时或父 Context 取消时，它也会自动触发取消)
	defer cancel()

	// 3. 创建用于接收后台任务结果和错误的 Channel
	resultChan := make(chan string, 1) // 缓冲区为1，防止 worker 完成但 handler 已超时退出导致阻塞
	errChan := make(chan error, 1)

	// 4. 启动后台 Goroutine 执行模拟的数据库查询
	//    将带超时的子 Context (ctx) 传递给后台任务
	go func() {
		log.Println("Handler: Starting background worker goroutine...")
		result, err := simulateDBQuery(ctx) // 把 ctx 传进去！
		if err != nil {
			errChan <- err
		} else {
			resultChan <- result
		}
	}()

	// 5. 使用 select "同时监听" 后台任务的结果/错误 或 Handler 自身的超时
	log.Println("Handler: Waiting for worker result or timeout...")
	select {
	case result := <-resultChan:
		// Case 1: 成功从后台任务接收到结果 (在 1 秒超时之前完成)
		log.Println("Handler: Received result from worker.")
		fmt.Fprintf(w, "Success: %s\n", result)

	case err := <-errChan:
		// Case 2: 从后台任务接收到错误 (可能是 worker 内部错误，或它检测到 context 取消)
		log.Printf("Handler: Received error from worker: %v\n", err)
		// 根据错误类型判断是超时还是其他取消
		if err == context.DeadlineExceeded {
			http.Error(w, "Request timed out by worker detecting context deadline", http.StatusGatewayTimeout)
		} else if err == context.Canceled {
			http.Error(w, "Request cancelled by worker detecting context cancellation", http.StatusInternalServerError) // 或其他合适的状态码
		} else {
			http.Error(w, fmt.Sprintf("Worker internal error: %v", err), http.StatusInternalServerError)
		}

	case <-ctx.Done():
		// Case 3: Handler 的 Context 超时了 (1 秒时间到，但后台任务还没完成)
		// 注意：这时后台的 simulateDBQuery 中的 `<-ctx.Done()` 也会被触发
		errMsg := fmt.Sprintf("Handler: Request context deadline exceeded: %v", ctx.Err())
		log.Println(errMsg)
		http.Error(w, "Request timed out by handler", http.StatusGatewayTimeout) // 504 Gateway Timeout
	}
	log.Println("Handler: Request processing finished.")
}

func main() {
	http.HandleFunc("/data", dataHandler)

	log.Println("Server starting on :8080...")
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
```

## GMP 模型


