## 8.3 并发业务应该使用 channel 还是 mutex

考虑到并发问题，我们是否可以使用通道或互斥锁来实现解决方案，这个太难选择了。由于 Go 提倡通过内存共享通信，一个错误的观念：强制使用通道，而不管用例如何。但是，我们应该将这两种选择视为互补。让我们在本节中弄明白如何选择。目标不是讨论我们可能面临的每一个可能的用例（这可能需要一本完整的书），而是提供可以帮助我们做出决定的一般指导方针。

首先，简单提一下 Go 中的通道：通道是一种通信机制。在内部，通道是一个管道，我们可以在其中发送和接收值，并允许连接并发的 goroutine。通道可以是：

* 无缓冲：发送者 goroutine 阻塞，直到接收者 goroutine 准备好。
* 有缓冲：发送者 goroutine 仅在缓冲区已满时阻塞。

让我们回到我们最初的问题。我们什么时候应该使用通道或互斥锁？我们将以下示例作为主干，其中包含三个具有特定关系的不同 goroutine：

![](https://img.exciting.net.cn/49.png)

在这个例子中：

* G1 和 G2 是并行的 goroutine。也许两个 goroutine 执行相同的函数并不断从一个通道接收消息，或者两个 goroutine 同时执行同一个 HTTP 处理程序。
* 另一方面，G1 和 G3 是并发 goroutine，G2 和 G3 也是。所有的 goroutine 都是整体并发结构的一部分，但 G1 和 G2 是第一步，而 G3 是下一步。

通常，并行 goroutines 必须同步。例如，当他们需要访问或改变共享资源（如切片）时。同步是使用互斥体强制执行的，但不是任何通道类型（不是缓冲通道）。因此，一般来说，并行 goroutine 之间的同步应该通过互斥体来实现。

相反，一般来说，并发的 goroutine 必须协调和编排。例如，如果 G3 需要汇总 G1 和 G2 的结果。在这种情况下，G1 和 G2 需要向 G3 发出新的中间结果可用的信号。这种协调属于沟通范围，因此属于渠道。

关于并发 goroutine，还有一种情况是我们希望将资源的所有权从一个步骤（G1 和 G2）转移到另一个步骤（G3）。例如，如果 G1 和 G2 正在丰富共享资源，并且在某个时候，我们认为这项工作已经完成。在这里，我们应该使用通道来表示特定资源已准备好并处理所有权转移。

互斥锁和通道具有不同的语义。每当我们想分享一个状态或访问共享资源，互斥锁确保对该资源的独占访问。相反，通道是一种机制，用于在有或没有数据的情况下发出信号（`chan struct{}` 与否）。协调或所有权转移应通过渠道实现。重要的是要知道 goroutine 是并行的还是并发的，因为一般来说，我们宁愿需要互斥体来处理并行的 
goroutine，而需要通道来处理并发的 goroutine。

现在让我们深入研究一个关于并发的广泛话题：竞争问题。