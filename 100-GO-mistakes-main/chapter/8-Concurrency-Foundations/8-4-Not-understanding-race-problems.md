## 8.4 竞争问题引入的坑

竞争问题可能是程序员可能面临的最困难和最隐蔽的错误之一。作为 Go 开发人员，我们必须了解数据竞争和竞争条件等关键方面、它们可能的影响以及如何避免它们。我们将首先讨论数据竞争与竞争条件来解决这些问题，然后我们将深入研究 Go 内存模型并解释其重要性。

### 8.4.1 数据竞争与竞争条件

让我们首先关注数据竞争。当两个或多个 goroutine 同时访问同一内存位置并且至少有一个正在写入时，就会发生数据竞争。这是一个示例，其中两个 goroutines 递增一个共享变量：

```go
i := 0
    
go func() {
    i++
}()

go func() {
    i++
}()
```

如果我们使用 Go 竞争检测器（`‑race` 选项）运行此代码，它将警告我们发生了数据竞争：

```shell
==================
WARNING: DATA RACE
Write at 0x00c00008e000 by goroutine 7:
  main.main.func2()

Previous write at 0x00c00008e000 by goroutine 6:
  main.main.func1()
==================
```

此外，`i` 的最终值是不可预测的，可能是1，也可能是2.

这段代码有什么问题？ `i++` 可以分解为三个操作：

* 读取 `i`
* 值递增
* 写回 `i`

如果第一个 goroutine 在第二个 goroutine 之前执行并完成，这里会发生什么：

| Goroutine 1 | Goroutine 2 | 操作  | `i` |
|-------------|-------------|-----|-----|
|             |             |     | 0   |
| 读           |             | <-  | 0   |
| 递增         |             |     | 0   |
| 写回          |             | ->  | 1   |
|             | 读           | <-  | 1   | 
 | | 递增| | 1|
 | | 写回| ->| 2|

第一个 goroutine 读取、递增并写回 `i` 值 1。然后，第二个 goroutine 执行相同的操作集，但从 1 开始。因此，写入i的最终结果将是 2。

但是，无法保证第一个 goroutine 会在上一个示例中的第二个 goroutine 之前开始或完成。我们还可能遇到交错执行的情况，其中两个 goroutine 将同时运行并竞争访问 `i`。这是另一种可能的情况:

| Goroutine 1 | Goroutine 2 | 操作  | `i` |
|-------------|-------------|-----|-----|
|             |             |     | 0   |
| 读           |             | <-  | 0   |
|             | 读           | <-  | 0   |
| 递增         |             |     | 0   |
|             | 递增         |     | 0   |
| 写回          |             | ->  | 1   |
|             | 写回          | ->  | 1   |

首先，两个 goroutines 从 `i` 读取并获得值 0。然后，都将它递增并写回它们的本地结果：1，这不是预期的结果。

这是数据竞争很有可能在并发请求时发生。如果两个 goroutine 同时访问同一个内存位置，并且至少有一个 goroutine 写入该内存位置，则可能会导致危险。更糟糕的是，在某些情况下，内存位置甚至可能最终保存一个包含无意义位组合的值。

> **Note** 我们将在 *不启用数据竞争标志* 中看到 Go 如何帮助我们检查数据竞争。

那么我们应该如何防止数据竞争的发生呢？让我们看看不同的技术解决方案。这里的范围不是展示所有可能的选项（例如，我们将省略 `atomic.Value`），而是给出主要解决方案。

第一个选项可能是使增量操作原子化，这意味着在单个操作中完成。这样，它可以防止纠缠的运行操作：

| Goroutine 1 | Goroutine 2 | 操作  | `i` |
|-------------|-------------|-----|-----|
|             |             |     | 0   |
| 读取并且递增     |             | <-> | 1   |
|             | 读取并且递增     | <->    | 2   |

即使第二个 goroutine 在第一个之前运行，结果仍然是 2。

原子操作可以在 Go 中使用 `atomic` 包实现。下面是一个示例，说明我们如何以原子方式递增一个 `int64` 类型的变量：

```go
var i int64
    
    go func() {
            atomic.AddInt64(&i, 1)
    }()
    
    go func() {
            atomic.AddInt64(&i, 1)
    }()
```

两个 goroutine 都以原子方式更新 `i`。原子操作不能被中断。因此，防止同时进行两次访问。不管 goroutine 的顺序执行如何，最终 `i` 将等于 2。

> **Note** `atomic` 包没有为 `int` 提供支持，但是为 `int32`、`int64`、`uint32` 和 `uint64` 提供支持。这就是为什么上一个例子中变量类型是 `int64`。

另一种选择是将两个 goroutine 与像互斥锁这样的临时数据结构同步。 Mutex 代表互斥，它确保最多有一个 goroutine 访问所谓的临界区。在 Go 中，`sync` 包提供了 `Mutex` 类型：

```go
i := 0
mutex := sync.Mutex{}

go func() {
    mutex.Lock()
    i++
    mutex.Unlock()
}()

go func() {
    mutex.Lock()
    i++
    mutex.Unlock()
}()
```

在此示例中，递增 `i` 是关键部分。不管 goroutines 的顺序如何，这个例子也为 `i` 产生了一个确定性的值：2。

哪种方法效果最好？边界非常简单。正如我们提到的，`atomic` 包只适用于特定类型。如果我们想要使用其他变量类型（例如，切片、映射和结构），我们就不能再依赖 `atomic` 了。

另一种可能的选择是防止共享相同的内存位置，而是支持跨 goroutine 的通信。例如，我们可以决定为每个 goroutine 创建一个通道来产生增量值：

```go
i := 0
ch := make(chan int)

go func() {
    ch <- 1
}()

go func() {
    ch <- 1
}()

i += <-ch
i += <-ch
```

每个 goroutine 通过通道通知我们应该将 `i` 递增 1。 父 goroutine 收集通知并递增 `i` 。因为它是唯一写入 `i` 的 goroutine，所以这个解决方案也是不会发生数据竞争的。

让我们总结一下到目前为止我们所遇到的案例。当多个 goroutine 同时访问同一个内存位置（例如，同一个变量）并且其中至少一个正在写入时，就会发生数据竞争。我们还看到了如何使用三种同步方法来防止它：

* 使用原子操作
* 使用互斥锁保护临界区
* 使用通道通信确保变量仅由单个 Goroutine 更新

在这三种方法中，无论两个 goroutine 的执行顺序如何，最终 `i` 的值都会设置为 2。然而，无论如何操作，总是如此吗？无数据竞争的应用程序是否一定意味着确定性结果？让我们用另一个例子来探讨这个问题。

现在不是让两个 goroutine 递增一个共享变量，而是每个 goroutine 都会进行分配。我们将使用使用互斥锁的方法来防止数据竞争：

```go
i := 0
mutex := sync.Mutex{}
go func() {
    mutex.Lock()
    defer mutex.Unlock()
    i = 1
}()

go func() {
    mutex.Lock()
    defer mutex.Unlock()
    i = 2
}()
```

第一个 goroutine 将 1 分配给 `i`，第二个 goroutine 将 2 分配给 `i`。

此示例中是否存在数据竞争？不，没有。两个 goroutine 都访问同一个变量，但不是在互斥锁保护它的同时访问。然而，这个例子是确定性的吗？不，不是。

根据排序执行，`i` 最终将等于 1 或 2。此示例不会导致数据竞争。然而，它有一个竞争条件。当行为取决于无法控制的事件的顺序或时间时，就会出现竞争条件。这里，事件发生的时间是 goroutine 的执行顺序。

确保 goroutine 之间的特定执行顺序是协调和编排的问题。如果我们想确保我们首先从状态 0 到状态 1，然后从状态 1 到状态 2，我们应该找到一种方法来保证 goroutines 是按顺序执行的。通道可以成为解决这个问题的一种方式。此外，如果我们协调和编排，它还可以确保特定部分仅由一个 goroutine 访问，这也可能意味着删除前面示例中的互斥锁。

总而言之，当我们在并发应用程序中工作时，了解数据竞争与竞争条件不同是很重要的。当多个 goroutine 同时访问同一内存位置并且其中至少一个正在写入时，就会发生数据竞争。数据竞争意味着意想不到的行为。然而，无数据竞争的应用程序并不一定意味着确定性的结果。事实上，一个应用程序可以没有数据竞争，但它的行为仍然取决于不受控制的事件（例如，goroutines 执行、消息发布到通道的速度、对数据库的调用将持续多长时间）；这是一个竞争条件。了解这两个方面对于精通并发应用程序的设计至关重要。

现在让我们深入研究 Go 内存模型并了解它的重要性。

### 8.4.2 Go 内存模型

上一节讨论了同步 goroutine 的三种主要技术：原子操作、互斥体和通道。但是，作为 Go 开发人员，我们应该了解一些核心原则。例如，关于通道：缓冲通道和非缓冲通道之间的效果是不同的。为了避免由于对语言核心规范缺乏了解而导致的意外竞争，我们必须深入研究 Go 内存模型。

Go 内存模型是一种规范，它定义了在不同的 goroutine 中写入同一个变量之后，可以保证读取一个 goroutine 中的变量的条件。换句话说，开发人员应该牢记避免数据竞争和强制确定性输出的效果。

在单个 goroutine 中，不会发生不同步的访问。事实上，happens‑before 顺序由我们的程序编写的顺序保证。

然而，在多个 goroutine 中，我们应该牢记其中的一些保证。我们将使用符号 A < B 来表示 事件 A 发生在事件 B 之前。让我们深入研究这些保证（一些从 Go 内存模型复制而来）：

* 创建 goroutine 发生在 goroutine 开始执行之前。因此，读取一个变量然后启动一个写入该变量的新 goroutine 不会导致数据竞争：

```go
i := 0
go func() {
    i++
}()
```

* 相反，goroutine 的退出不能保证在任何事件之前发生。因此，以下示例存在数据竞争：

```go
i := 0
go func() {
    i++
}()
fmt.Println(i)
```

同样，如果我们想防止数据竞争的发生，我们应该同步执行这些 goroutine。

```go
i := 0
ch := make(chan struct{})
go func() {
    <-ch
    fmt.Println(i)
}()
i++
ch <- struct{}{}
```

顺序如下：

```shell
变量自增 < 通道发送 < 通道接收 < 变量读取
```

通过传递性，我们可以确保对 `i` 的访问是同步。因此，免于数据竞争。

* 关闭通道发生在接收此关闭之前。下一个示例与上一个示例类似，只是我们关闭通道而不是发送消息：

```go
i := 0
ch := make(chan struct{})
go func() {
    <-ch
    fmt.Println(i)
}()
i++
close(ch)
```

因此，这个例子也没有数据竞争。

* 乍一看，关于通道的最后一个可能违反直觉：来自无缓冲通道的接收发生在该通道上的发送完成之前。

首先，让我们看一个不是无缓冲但有缓冲通道的示例。我们将有两个 goroutine，父级发送消息并读取一个变量，而子级更新此变量并从通道接收：

```go
i := 0
ch := make(chan struct{}, 1)
go func() {
    i = 1
    <-ch
}()
ch <- struct{}{}
fmt.Println(i)
```

这个例子导致了数据竞争。让我们直观地看一下这个例子：

![](https://img.exciting.net.cn/50.png)

我们可以观察到对 `i` 的读和写可能同时发生；因此，`i` 不是同步的。现在，让我们将通道更改为无缓冲通道以说明内存模型保证：

```go
i := 0
ch := make(chan struct{})
go func() {
    i = 1
    <-ch
}()
ch <- struct{}{}
fmt.Println(i)
```

更改通道类型使此示例数据无竞争：

![](https://img.exciting.net.cn/51.png)

在这里，我们可以看到主要区别：写入保证在读取之前发生。请注意，箭头并不代表因果关系（当然，接收是由发送引起的）。它代表了 Go 内存模型的顺序保证。由于来自无缓冲通道的接收发生在发送之前，因此对 `i` 的写入将始终发生在读取之前。

在本节中，我们介绍了 Go 内存模型的主要保证。在编写并发代码时，理解这些保证应该是我们核心知识的一部分。事实上，它可以防止我们做出可能导致数据竞争和/或竞争条件的错误假设。

以下部分将讨论为什么了解工作负载类型很重要。