## 12.9 Go 的垃圾回收是如何工作的

垃圾收集器 (GC) 是 Go 语言的关键部分，旨在简化开发人员的生活。它允许跟踪和释放不再需要的堆分配。由于我们不能用栈分配替换每个堆分配，因此了解 GC 的工作原理应该是 Go 开发人员优化应用程序的工具集的一部分。

### 12.9.1 概念

GC 保留对象引用的树。Go GC 基于标记清除(mark-and‑sweep)算法，它依赖于两个阶段：

* 标记阶段：遍历堆的所有对象，标记它们是否还在使用
* 清除阶段：从根开始遍历引用树并释放不再引用的对象块

当一个 GC 运行时，它首先执行一组不同的动作来停止世界（准确地说，每个 GC 有两个 stop‑the‑world）。换句话说，所有可用的 CPU 时间都将用于执行 GC，从而暂停我们的应用程序代码。按照这些步骤，它再次启动世界，恢复我们的应用程序，但同时运行一个并发阶段。出于这个原因，Go GC 被称为并发标记和清除，因为它旨在减少每个 GC 周期的 stop‑the‑world 操作量，以便大部分与我们的应用程序同时运行。

Go GC 还包括一种在消耗高峰后释放内存的方法。想象我们的应用程序基于两个阶段：

* 会导致频繁分配和大堆的初始化阶段
* 具有适度分配和小堆的运行时阶段

Go 将如何解决大堆仅在应用程序启动时有用但在应用程序启动后无用的事实？它作为 GC 的一部分使用所谓的周期性清除程序进行处理。一段时间后，GC 会检测到不再需要这么大的堆。因此，它将释放一些内存并将其返回给操作系统。

> **Note** 如果清除程序不够快，我们还可以使用 `debug.FreeOSMemory()` 手动强制将内存返回给操作系统。

因此，理解一个重要的问题是 GC 周期何时运行？事实上，与 Java 等其他语言相比，在 Go 中，配置仍然相当简单，因为它依赖于一个环境变量：`GOGC`。该变量定义自上次 GC 以来堆在触发另一次 GC 之前的百分比，默认情况下：100%。

一个具体的例子来确保我们理解它。假设当前堆大小为 128 MB。如果 `GOGC=100`，当堆大小达到 256 MB 时将触发下一次 GC。因此，每当堆大小翻倍时，默认情况下都会触发 GC。此外，如果在过去两分钟内未执行 GC，Go 将强制运行一次。

如果我们用生产负载分析我们的应用程序，我们可以尝试微调 `GOGC`：

* 减少它会导致堆增长更慢，增加GC的压力
* 反之，碰撞它会导致堆增长更快，减少GC的压力

> **Note** 启用 `gctrace` 将在每次 GC 运行时将跟踪写入 `stderr`。
> 
> 我们可以通过设置 `GODEBUG` 环境变量来打印 GC 跟踪。例如，在运行基准测试时：
> ```shell
> $ GODEBUG=gctrace=1 go test -bench=. -v
> ```

让我们通过具体的例子来了解在负载增加的情况下 GC 将如何表现。

### 12.9.2 具体例子

假设我们向用户公开了一些公共服务。在上午 12 点的高峰时段，将有 100 万用户连接。但是，连接过的用户数量将逐步稳定。

在下图中，我们将表示平均堆大小，以及如果我们将 `GOGC` 保持为 100 将何时触发 GC ：

![](https://img.exciting.net.cn/120.png)

由于 `GOGC` 设置为 100，因此每次堆大小翻倍时都会触发 GC。在这些情况下，随着用户数量的稳步增加，我们应该全天面临可接受的 GC 数量：

![](https://img.exciting.net.cn/121.png)

我们应该在一天开始时有适度数量的 GC 周期。直到凌晨 12 点用户数量开始减少时，GC 周期数也应该稳步减少。在这种情况下，将 `GOGC` 保持在 100 应该是完全没问题的。 

现在，让我们考虑第二种情况，其中 100 万用户中的大多数在不到一个小时内连接：

![](https://img.exciting.net.cn/123.png)

早上 8 点，平均堆大小迅速增长，大约在 1 小时内达到峰值。在这种情况下，GC 周期的频率应该在这一小时内受到严重影响：

![](https://img.exciting.net.cn/124.png)

由于堆的显着和突然的碰撞，我们将在短时间内面临频繁的 GC 周期。即使 Go GC 是并发的，它也会导致在此期间出现大量的 stop-the-world 周期。这种情况会产生一些影响，例如用户看到的平均延迟。 

在这种情况下，可能应该考虑将 `GOGC` 提高到更高的值以减轻 GC 的压力。请注意，增加 `GOGC` 不会带来线性收益。堆越大，清理它所需的时间就越长。因此，在使用生产负载时，应谨慎处理配置 `GOGC`。

我们还可以注意到，在特殊情况下，颠簸会更加显着，调整 `GOGC` 可能还不够。例如，假设我们不是在一小时内从零增加到一百万用户，而是在几秒钟内完成。在这几秒钟内，GC 的数量可能会达到临界状态，导致应用程序性能非常差。

在这种情况下，如果堆峰值已知，我们可以应用一个技巧。它涉及强制分配大量内存以提高堆的稳定性。

例如，我们可以在 `main.go` 中使用全局变量强制分配 1 GB：

```go
var min = make([]byte, 1_000_000_000) // 1 GB
```

这样分配的意义何在？如果 `GOGC` 保持在 100，那么 Go 不会在每次堆翻倍时触发 GC（在这几秒钟的小间隔内再次非常频繁），Go 只会在堆达到 2 GB 时触发 GC。因此，它应该减少所有用户连接时触发的 GC 周期数，从而减少此期间对平均延迟的影响。

但是，我们可以争辩说，当堆大小减小时，会浪费大量内存。然而，事实并非如此。在大多数操作系统上，这个 `min` 变量的分配不会导致我们的应用程序必然消耗 1 GB 的内存。实际上，调用 `make` 会导致对 `mmap()` 的系统调用，这会以某种方式导致延迟分配。事实上，例如，在 Linux 上，内存是通过页表虚拟寻址和映射的。使用 `mmap()` 只会在虚拟地址空间中分配 1 GB 的内存，而不是物理空间。只有读取或写入会导致页面错误，从而导致实际的物理内存分配。

> **Note** 我们可以使用 `ps` 等工具来验证这种行为。

因此，即使应用程序在没有任何连接的客户端的情况下启动，它也不会消耗 1 GB 的物理内存。

总结 GC，必须了解它的行为以优化它。作为 Go 开发者，我们可以使用 `GOGC` 来配置下一次 GC 周期何时触发。在大多数情况下，将其保持在 100 就足够了。但是，如果我们的应用程序可能面临导致频繁 GC 和延迟影响的请求高峰，我们可以增加此值。最后但并非最不重要的一点是，在请求异常高峰的情况下，可以考虑使用将虚拟堆大小保持在最小的技巧。

本章的最后一部分将讨论在 Docker 和 Kubernetes 中运行 Go 的影响。