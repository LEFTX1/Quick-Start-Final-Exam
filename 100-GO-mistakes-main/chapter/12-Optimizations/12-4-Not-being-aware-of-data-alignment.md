## 12.4 数据在内存中对齐，有什么好处

数据对齐是一种安排数据分配方式以加快 CPU 访问内存的方式。不了解这个概念会导致额外的内存消耗，甚至降低性能。本节将深入研究这个概念，描述它的应用，以及防止代码优化不足的技术。

要了解数据对齐的工作原理，让我们首先讨论没有它会发生什么。

假设我们分配了两个变量：一个 `int32`（32 字节）和一个 `int64`（64 字节）。

```go
var i int32
var j int64
```

如果没有数据对齐，在 64 位架构上，这两个变量可以这样分配：

![](https://img.exciting.net.cn/97.png)

`j` 变量分配可以用两个词展开。如果 CPU 想要读取 `j`，它会导致两次内存访问而不是一次。

为了防止这种情况，变量的内存地址应该是其自身大小的倍数。这就是数据对齐的概念。在 Go 中，对齐方式如下：

* byte、uint8、int8：1 字节 
* uint16、int16：2 字节 
* uint32、int32、float32：4 字节 
* uint64、int64、float64、complex64：8 字节 
* complex128：16 字节

所有这些类型都保证是对齐的：地址是它们大小的倍数。例如，任何 `int32` 变量的地址都是 4 的倍数。

让我们回到现实世界，看看 `i` 和 `j` 在内存中分配的两种不同情况：

![](https://img.exciting.net.cn/98.png)

在第一种情况下，在 `i` 之前分配了一个 32 位变量。因此，`i` 和 `j` 是连续分配的。

在第二种情况下，这个 32 位变量没有在 `i` 之前分配（例如，它是一个 64 位变量）；因此，`i` 被分配在单词的开头。关于 `j` ，为了尊重数据对齐（地址是 64 的倍数），它可以与 `i` 一起分配，但分配给下一个 64 的倍数。灰色框表示 32 位填充。

现在让我们了解何时填充可能是一个问题。我们将考虑以下包含三个字段的结构：

```go
type Foo struct {
    b1 byte
    i  int64
    b2 byte
}
```

考虑到 `byte` 类型（一个字节）和 `int64`（8 个字节），在 64 位架构上，结构将通过以下方式分配到内存中：

![](https://img.exciting.net.cn/99.png)

`b1` 首先分配。然后，由于 `i` 是一个 `int64` 变量，它的地址必须是 8 的倍数。因此，不可能将它与 `b1` 一起分配到 0x01。那么，下一个地址是 8 的倍数吗？0x08。关于 `b2`，变量被分配给下一个可用地址，它是一个的倍数：0x10。

由于结构体的大小必须是字大小（8 字节）的倍数，所以它的地址不是 17 字节，而是总共 24 字节。在编译过程中，Go 编译器会添加填充以保证数据对齐：

```go
type Foo struct {
    b1 byte
    _  [7]byte
    i  int64
    b2 byte
    _  [7]byte
}
```

因此，每次创建 `Foo` 结构体时，都需要 24 个字节的内存，但只有 10 个字节包含实际数据。剩余的 14 个字节将被填充。同时，由于 struct 是一个原子单元，即使经过GC，struct 也不会被重组；它将始终占用内存中的 24 个字节。请注意，编译器不会重新排列字段；它只添加填充以保证数据对齐。

那么，我们怎样才能减少分配的内存量呢？经验法则是重新组织结构，使其字段按类型大小降序排列。在我们的例子中，`int64` 类型是第一个，后面是两个字节类型：

```go
type Foo struct {
    i  int64
    b1 byte
    b2 byte
}
```

现在，这是新版本的 `Foo` 在内存中的分配方式：

![](https://img.exciting.net.cn/100.png)

`i` 先分配，占用一个完整的字。然后，主要区别在于现在 `b1` 和 `b2` 可以在同一个单词中并存。

同样，该结构必须是字长的倍数，但不是占用内存中的 24 个字节，而是 仅占用 16 个字节。因此，仅仅因为我们将i移到了第一个位置，就节省了 33% 的内存。

如果我们使用 `Foo` 结构的第一个版本（24 字节）而不是压缩的结构，具体的影响是什么？

首先，如果 `Foo` 被保留（例如，内存中的 `Foo` 缓存），它将消耗额外的内存。但是，即使 `Foo` 不保留，也会导致其他影响。例如，如果我们频繁地创建 `Foo` 变量并且如果这些变量被分配到堆中（我们将在下一节讨论这个概念），这将导致更频繁的 GC，从而影响整体应用程序的性能。

说到性能，对空间局部性还有另一个影响。例如，让我们考虑将 `Foo` 结构切片作为参数的 `sum` 函数。此函数将遍历切片并对所有 `i` 字段 (int64) 求和：

```go
func sum(foos []Foo) int64 {
    var s int64
    for i := 0; i < len(foos); i++ {
        s += foos[i].i
    }
    return s
}
```

由于切片由数组支持，这意味着 `Foo` 结构的连续分配。

让我们深入研究 `Foo` 的两个版本的后备数组，并检查两个缓存行数据（128 字节）。每个灰色条代表 8 个字节的数据，较暗的是 `i` 变量（我们要求和的字段）：

![](https://img.exciting.net.cn/101.png)

正如我们在视觉上看到的那样，使用最新版本的 `Foo`，每个缓存行都会更有用；从某种意义上说，它将包含平均多 33% 的 `i` 变量。因此，迭代 `Foo` 切片以对所有 `int64` 元素求和会更有效。

我们可以用一个基准来证实这个观察结果。如果我们使用 10k 元素的切片对两个版本的 `Foo` 运行两个基准测试，则使用最新的 `Foo` 结构的版本在我的机器上快了大约 15%。通过更改结构中单个字段的位置，速度提高了 15%。 

让我们注意数据对齐。正如我们在本节中看到的那样，重新组织 Go 结构的字段以按大小按降序对它们进行排序是一种防止填充的方法。 防止填充意味着分配更紧凑的结构，从而导致一些优化，例如可能降低 GC 的频率和可能更好的空间局部性。

下一节将讨论堆栈和堆之间的根本区别，并了解其重要性。