## 4.2 在 `range` 循环中被忽视的参数求值方式

`range` 后接一个表达式。例如，在 `for i, v:= range exp` 中，`exp` 是表达式。正如我们所见，它可以是字符串、数组、指向数组的指针、切片、映射或channel。现在，让我们讨论以下问题：如何求值(`evaluated`)这个表达式？这个问题关系到使用`range`循环的重中之重。

让我们看以下示例，在这个例子中，我们将元素附加到迭代的切片。你觉得这个循环会终止吗？

```go
s := []int{0, 1, 2}
for range s {
    s = append(s, 10)
}
```

要回答这个问题，我们应该知道，当使用 `range` 循环时，提供的表达式只在循环开始之前被求值一次。在这种情况下，求值意味着提供的表达式被复制到一个临时变量，然后 `range` 将遍历这个临时变量，而不是原始变量。

在这个例子中，当 `s` 表达式被求值时，它会产生一个切片拷贝。

![](https://img.exciting.net.cn/30.png)

`range` 循环将使用这个拷贝的临时变量。此外，原始切片s在每次迭代时都会更新。因此，经过3次迭代后，状态如下：

![](https://img.exciting.net.cn/31.png)

迭代的每一步都会导致附加一个新元素。经过三步之后，我们遍历了临时变量的所有元素。总结一下整个过程，临时变量自从复制之初到最后，所指定的一直是长度为3的切片，所以整个迭代三步就结束了。

对于经典的 `for` 循环，行为会有所不同：

```go
s := []int{0, 1, 2}
for i := 0; i < len(s); i++ {
    s = append(s, 10)
}
```

在此示例中，循环永远不会结束。因为在每次迭代时都会计算 `len(s)` 表达式的值。随着我们不断添加元素，将永远不会达到终止状态。为了准确使用 Go 循环，必须牢记这种差异。

回到 `range` 运算符，我们应该知道我们描述的行为（表达式只求值一次）也适用于所有提供 的数据类型。作为补充案例，我们将观察这种行为对另外两种类型的影响：channel和数组。

### 4.2.1 channel

让我们看一个基于 `range` 循环在channel上迭代的示例。

我们将创建两个 goroutine，分别将元素发送到这两个channel。然后，在父 goroutine中，我们使用 `range` 循环在一个channel上实现消费者，在循环内部间尝试切换到另一个channel：

```go

ch1 := make(chan int, 3)
go func() {
    ch1 <- 0
    ch1 <- 1
    ch1 <- 2
    close(ch1)
}()

ch2 := make(chan int, 3)
go func() {
    ch2 <- 10
    ch2 <- 11
    ch2 <- 12
    close(ch2)
}()

ch := ch1
for v := range ch {
    fmt.Println(v)
    ch = ch2
}
```

在此示例中，range后表达式只会求值一次同样适用。提供给 `range` 的表达式是指向 `ch1` 的 `ch` channel。因此 `range` 求值 `ch`，对临时变量执行复制，并迭代来自该channel的元素。尽管有 `ch = ch2` 语句，但 `range` 将继续迭代 `ch1` ，而不是 `ch2`。

```go
0
1
2
```

不过，`ch = ch2` 语句并非无效。当我们将 `ch` 分配给第二个变量时，如果我们在这段代码之后调用`close(ch)` ，它将关闭ch2，而不是ch1。

现在让我们看看对数组的影响。

### 4.2.2 数组

对数组使用 `range` 循环有什么影响？由于 `range` 表达式是在循环开始之前求值的，因此会分配数组的副本给临时变量。在下面这个例子中，我们会在迭代期间更新数组特定索引上的数值，让我们来看看这个原理(表达式只会求值一次)的实际作用：

```go
a := [3]int{0, 1, 2}
for i, v := range a {
        a[2] = 10
        if i == 2 {
                fmt.Println(v)
        }
}
```

此代码将数组a最后一个索引上的元素更新为10。但是，如果我们运行此代码，它不会打印 10，而是打印 2，如下图所述：

![](https://img.exciting.net.cn/32.png)

正如我们所提到的，`range` 运算符创建了数组的副本。同时，循环不会更新副本；它更新原始数组：`a`。因此，最后一次迭代中 `v` 的值是 2，而不是 10。

如果我们想打印数组a最后一个元素值，有以下的实现方式：
* 通过从其索引访问元素：
```go
a := [3]int{0, 1, 2}
for i := range a {
        a[2] = 10
        if i == 2 {
                fmt.Println(a[2])
        }
}
```
* 使用数组指针
```go
a := [3]int{0, 1, 2}
for i, v := range &a {
        a[2] = 10
        if i == 2 {
                fmt.Println(v)
        }
}
```

这两个选项都有效。但是，第二个选项不会导致复制整个数组，如果数组非常大，记住这一点是很有用的。

总之， `range` 循环仅在循环开始之前通过复制（无论类型如何）对提供的表达式求值一次。我们应该记住这种行为，以避免常见错误，例如，访问错误的元素。

在下一节中，我们将看到如何使用带指针的 `range` 循环来避免常见错误。