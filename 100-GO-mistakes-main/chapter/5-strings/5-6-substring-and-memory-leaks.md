## 5.6 子字符串与内存泄漏

在 *切片和内存泄漏* 中，我们已经看到切片切片或数组可能会导致内存泄漏情况。此原则也适用于字符串和子字符串操作。首先，我们将了解 Go 中如何处理子字符串并防止内存泄漏。

要提取字符串的子集，我们可以使用以下语法：

```go
s1 := "Hello, World!"
s2 := s1[:5] // Hello
```

`s2` 被构造为 `s1` 的子串。此示例从前五个字节创建一个字符串，而不是前五个字符。因此，我们不应该在使用多字节编码的字符的情况下使用这种语法。相反，我们应该首先将输入字符串转换为 `[]rune` 类型：

```go
s1 := "Hêllo, World!"
s2 := string([]rune(s1)[:5]) // Hêllo
```

现在我们对子字符串操作有了新的认识，让我们深入研究一个具体的问题来说明可能的内存泄漏。

我们将接收日志消息作为字符串。每个日志将首先使用 UUID（36 字节）格式化，然后是消息本身。我们希望将这些 UUID 存储在内存中，例如，保存最新的 n 个 UUID 的缓存。我们还应该注意，这些日志消息可能非常庞大（高达数千字节）。这是我们的实现：

```go
func (s store) handleLog(log string) error {
        if len(log) < 36 {
                return errors.New("log is not correctly formatted")
        }
        uuid := log[:36]
        s.store(uuid)
        // Do something
}
```

为了提取 UUID，我们使用 `log[:36]` 的子字符串操作，因为我们知道 UUID 被编码为 36 个字节。然后，我们将此 `uuid` 变量传递给将其存储在内存中的 `store` 方法。这个解决方案有问题吗？是的，有问题。

在进行子字符串操作时，Go 规范没有指定结果字符串和子字符串操作中涉及的字符串是否应该共享相同的数据。然而，标准的 Go 编译器确实让它们共享相同的后备数组，这可能是最好的解决方案内存和性能，因为它可以防止新的分配和复制。

我们提到日志消息可能非常庞大。`log[:36]` 将创建一个引用相同支持数组的新字符串。因此，我们将存储在内存中的每个 `uuid` 字符串不会只包含 36 个字节，而是包含初始 `log` 字符串中的字节数；因此可能有数千个字节。

我们该如何解决？通过制作子字符串的深层副本，以便 `uuid` 的内部字节切片仅引用一个新的 36 字节支持数组：

```go
func (s store) handleLog(log string) error {
        if len(log) < 36 {
                return errors.New("log is not correctly formatted")
        }
        uuid := string([]byte(log[:36]))
        s.store(uuid)
        // Do something
}
```

通过首先将子字符串转换为 `[]byte`，然后再转换为字符串来执行复制。通过这样做，我们可以防止发生内存泄漏。`uuid` 字符串将由仅包含36个字节的数组支持。

请注意，某些 IDE 或 linter 可能会强调 `string([]byte(s))` 转换不是必需的。 例如，JetBrains IDE GoLand 会针对冗余类型转换发出警告。在我们将字符串转换为字符串的意义上，这是正确的，但是这个操作有一个实际的效果。如前所述，它可以防止新字符串由与 `uuid` 相同的数组支持。请注意，IDE 或 linter 发出的警告有时可能不准确。

> **Note** 由于字符串主要是指针，因此调用函数来传递字符串不会导致字节的深拷贝。复制的字符串仍将引用相同的支持数组。因此，我们在调用函数时不应该考虑字符串的长度。此外，进行深拷贝的方法是 `string([]byte(s))`.

从 Go 1.18 开始，标准库还包括一个带有 `strings.Clone` 的解决方案，它返回一个字符串的新副本：

```go
uuid := strings.Clone(log[:36])
```

调用 `strings.Clone` 将 `log[:36]` 的副本复制到新的分配中，防止任何内存泄漏。

在 Go 中使用子字符串时要记住两件事。首先，提供的间隔是基于字节数，而不是字符数。其次，它可能导致内存泄漏，因为子字符串将与初始字符串共享相同的后备数组。防止这种情况发生的解决方案是手动执行字符串复制或使用Go 1.18 中的 `strings.Clone`。