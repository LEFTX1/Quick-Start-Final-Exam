## 3.8 无法正确复制切片

`copy` 内置函数允许将元素从一个源切片复制到目标切片。尽管它很方便，但`Go`开发人员有时会误用它。让我们看看一个复制错误切片元素数量的常见错误。

在下面的示例中，我们将创建一个切片并将其元素复制到另一个切片。这段代码的输出应该是什么？

```go
src := []int{0, 1, 2}
var dst []int
copy(dst, src)
fmt.Println(dst)
```

如果我们运行这个例子，它将打印 `[]`，而不是 `[0 1 2]`。原因何在？

为了正确地使用 `copy`，必须了解，复制到目标切片的元素数量应是下面的最小值：

* 源切片的长度
* 目标切片的长度

在前面的示例中，`src` 是一个长度为`3`的切片，但 `dst` 是一个长度为`0`的切片，因为它被初始化为零值。因此，`copy` 将复制`3`与`0`之间的最小值，即`0`个元素。结果切片为空。

如果我们想要执行完整的复制，目标切片的长度必须大于或等于源切片的长度。在这里，我们将根据源切片设置一个长度：

```go
src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst)
```

由于 `dst` 现在是一个长度为`3`的切片，它将复制三个元素。这一次，如果我们运行这段代码，它将打印 `[0 1 2]`。

> **Note** 另一个常见的错误是在调用 `copy` 时颠倒了参数的顺序。请记住，目标是第一个参数，而源是后者。

我们还要提一下，使用`copy` 内置函数并不是复制切片元素的唯一方法。有不同的选择，最容易被人想到的可能是使用 `append` 的方法：

```go
src := []int{0, 1, 2}
dst := append([]int(nil), src...)
```

我们将源切片中的元素附加到零切片。因此，此代码创建了一个长度为`3`、容量为`3`的切片副本。这种替代方案的优点是可以在单行中完成。然而，使用 `copy` 更惯用，因此更容易理解，即使它需要额外的一行。

将元素从一个切片复制到另一个切片是相当常见的操作。使用 `copy` 时，我们必须记住，复制到目标的元素数量等于两个切片长度之间的最小值。另外，请记住，存在复制切片的其他替代方案，因此如果我们在代码库中发现它们，我们不应该感到惊讶。

后面我们将继续讨论使用`append`时常见错误。