## 7.2 被忽略的包装(wrap)错误

从 Go 1.13 开始，`%w` 指令允许我们方便地包装错误。然而，一些开发人员可能会对我们何时应该包装错误感到困惑。所以，让我们提醒自己什么是错误包装以及何时使用它。

错误包装是关于在包装容器内包装或打包错误，这也使源错误可用：

![](https://img.exciting.net.cn/38.png)

通常，错误包装的两个主要用例如下：

* 为错误添加额外的上下文
* 将错误标记为特定错误

关于添加上下文，我们可以考虑以下示例。我们收到来自特定用户的访问数据库资源的请求，但在查询期间收到权限被拒绝错误。出于调试目的，如果最终记录了错误，我们希望添加额外的上下文。在这种情况下，我们可以包装错误以指示用户是谁以及访问的资源是什么：

![](https://img.exciting.net.cn/39.png)

现在假设我们不想添加上下文，而是要标记错误。例如，我们要实现一个 HTTP 处理程序，检查调用函数时收到的所有错误是否都是 `Forbidden` 类型，以返回403状态码。在这种情况下，我们可以将此错误包装在 `Forbidden` 中：

![](https://img.exciting.net.cn/40.png)

在这两种情况下，源错误仍然可用。因此，调用者也可以通过解包并检查源错误来处理错误。我们还要注意，有时我们希望将这两种方法结合起来：添加上下文和标记错误。

现在我们已经阐明了包装错误的主要用例，让我们看看 Go 中返回我们收到的错误的不同方式。我们将考虑以下代码，并探索 `if err != nil` 块中的不同选项：

```go
func Foo() error {
    err := bar()
    if err != nil {
        // ?
    }
    // ...
}
```

第一种选择是直接返回此错误。事实上，如果我们不想标记错误或者没有可以考虑添加的有用上下文，那么这种方法非常好：

```go
if err != nil {
    return err
}
```

在这里，我们返回相同的错误：

![](https://img.exciting.net.cn/41.png)

在 Go 1.13 之前，要包装错误，不使用任何外部库的唯一选择是创建自定义错误类型：

```go
type BarError struct {
    Err error
}

func (b BarError) Error() string {
    return "bar failed:" + b.Err.Error()
}
```

然后，我们不直接返回`err`，而是将错误包装到 `BarError` 中：

```go
if err != nil {
    return BarError{Err: err}
}
```

![](https://img.exciting.net.cn/42.png)

这个选项的好处是它的灵活性。由于 `BarError` 是一个自定义结构，我们可以根据需要添加任何额外的上下文。但是，如果我们想重复这个操作，必须创建一个特定的错误类型会很快变得很麻烦。

为了克服这种情况，Go 1.13 引入了 `%w` 指令：

```go
if err != nil {
    return fmt.Errorf("bar failed: %w", err)
}
```

此代码包装源错误以添加额外的上下文，而无需创建另一个错误类型：

![](https://img.exciting.net.cn/43.png)

由于源错误仍然可用，客户端可以解开父错误，然后检查源错误是否属于特定类型或值（我们将在下一节中讨论这些点）。

我们将讨论的最后一个选项是使用 `%v` 指令：

```go
if err != nil {
    return fmt.Errorf("bar failed: %v", err)
}
```

这里的区别是错误本身没有被包装。我们将其转换为另一个错误以添加上下文，但源错误本身不再可用：

![](https://img.exciting.net.cn/44.png)

有关问题根源的信息仍然可用。但是，调用者无法解开此错误并检查源是否为 `bar error`。因此，从某种意义上说，此选项比 `%w` 更具限制性。但是，既然 `%w` 指令已经发布，我们应该阻止这种情况吗？不必要。

包装错误使调用者可以使用源错误。因此，这意味着引入潜在的耦合。例如，假设我们使用包装并且 `Foo` 的调用者检查源错误是否为 `bar error`。现在，如果我们想改变我们的实现并使用另一个会返回另一种错误的函数？它将破坏调用者所做的错误检查。

如果我们想确保我们的客户不依赖我们考虑的东西作为实现细节，那么返回的错误不应该被包装，而是类型转换。在这种情况下，使用 `%v` 来取代可能使用 `%w` 的地方。

因此，让我们总结一下我们处理的所有不同选项：

| 选项                  | 额外的上下文               | 标记一个错误 | 源操作可用                   |
|---------------------|----------------------|--------|-------------------------|
| 直接返回错误              | N                    | N      | Y                       |
| 自定义错误类型             | 可能的（如果错误类型包含一个字符串字段） | Y      | 可能的（如果错误源是可导出的或者可访问的方法） |
| `fmt.Errorf` 与 `%w` | Y                    | N      | Y                       |
| `fmt.Errorf` 与 `%Y` | Y                    | N      | N                       |

总而言之，在处理错误时，我们可以决定包装它。包装是关于向错误添加额外的上下文且/或将错误标记为特定类型。如果我们需要标记错误，我们应该创建一个自定义错误类型。但是，如果我们只想添加额外的上下文，我们应该使用 `fmt.Errorf` 和 `%w` 指令，因为它不需要创建新的错误类型。但是，错误包装会产生潜在的耦合，因为它使源错误可用于调用者。如果我们想阻止它，我们不应该使用错误包装，而是使用错误转换，例如，使用带有 `%v` 指令的 `fmt.Errorf`。

本节介绍了如何使用 `%w` 指令包装错误。但是一旦我们开始使用它，比较一个错误类型有什么影响呢？