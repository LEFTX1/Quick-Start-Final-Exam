## 7.6 忽略错误，引入的坑

在某些情况下，我们可能希望忽略函数返回的错误。如果我们遇到这种情况，在 Go 中应该只有一种方法。让我们搞明白为什么。

我们思考以下示例，其中我们调用一个返回单个 `error` 参数的 `notify` 函数。然而，由于我们对这个错误不感兴趣，我们将故意省略任何错误处理：

```go
func f() {
        // ...
        notify()
}

func notify() error {
        // ...
}
```

因为我们想忽略错误，所以在这个例子中，我们只是调用了 `notify` 而没有将其输出分配给经典的 `err` 变量。从功能的角度来看，这段代码没有任何问题：它将按预期编译和运行。

但是，从可维护性的角度来看，它可能会导致一些问题。让我们考虑一个新读者到达此代码。这位读者注意到 `notify` 返回一个错误，但它没有由上级函数处理。他怎么能猜到是不是故意的？他怎么知道之前的开发者是忘记处理还是故意的？

由于这些原因，当我们想要忽略 Go 中的错误时，有一种语法糖：

```go
_ = notify()
```

我们没有将错误分配给变量，而是将其分配给空白标识符。编译和运行时方面，与第一段代码相比，它没有任何改变。然而，这个新版本明确表明我们对错误不感兴趣。

注释也可以伴随这样的代码。没有评论提及我们忽略了这样的错误：

```go
// Ignore the error
_ = notify()
```

此注释重复了代码的作用，应避免使用。但是，指出忽略此错误的原因可能是个好主意。例如：

```go
// Notifications are sent in best effort.
// Hence, it's accepted to miss some of them in case of errors.
_ = notify()
```

忽略 Go 中的错误应该是例外的。在许多情况下，我们可能仍然倾向于记录它们，即使是在较低的日志级别。然而，如果我们确定一个错误可以并且应该被忽略，我们必须通过将它分配给空白标识符来明确地做到这一点。这样，未来的读者就会明白这是故意的。

现在让我们讨论本章的最后一部分，如何处理 defer 函数返回的错误。