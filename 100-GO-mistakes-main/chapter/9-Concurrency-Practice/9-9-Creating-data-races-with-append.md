## 9.9 append 数据引发的数据竞争

我们在上一节中提到了什么是数据竞争及其影响。现在，让我们深入研究切片并讨论使用 `append` 将元素添加到切片是否是无数据竞争的。

在下面的示例中，我们将初始化一个切片并创建两个 goroutine，它们将使用 `append` 创建一个带有附加元素的新切片：

```go
s := make([]int, 1)
    
go func() {
    s1 := append(s, 1)
    fmt.Println(s1)
}()

go func() {
    s2 := append(s, 1)
    fmt.Println(s2)
}()
```

你认为这个例子有数据竞争吗？答案是不。

我们必须回忆一下我们在数据类型一章中描述的一些切片基础知识。切片由数组支持，它有两个属性：长度和容量。长度是切片中可用元素的数量，而容量是后备数组中元素的总数。当我们使用 `append` 时，行为取决于切片是否已满（长度 == 容量）。如果是，它会创建一个新的后备数组来添加新元素；否则，它将其添加到现有的支持数组。

在这个例子中，我们使用 `make([]int, 1)` 创建了一个切片。此示例创建一 个长度为 1、容量为 1 的切片。因此，当切片已满时，在每个 goroutine 中使用 `append` 将返回一个由新数组支持的切片。它不会改变现有的数组；因此它不会导致数据竞争。

现在，让我们运行相同的示例，但对 `s` 的初始化方式稍作更改。我们将创建长度为零但容量为一的切片，而不是创建长度为一的切片：

```go
s := make([]int, 0, 1)

// Same
```

这个新例子怎么样？它是否包含数据竞争？答案是肯定的：

```shell
==================
WARNING: DATA RACE
Write at 0x00c00009e080 by goroutine 10:
  ...

Previous write at 0x00c00009e080 by goroutine 9:
  ...
==================
```

在这里，我们使用 `make([]int, 0, 1)` 创建了一个切片。因此，数组未满。因此，两个 goroutine 都尝试更新后备数组的相同索引（索引 1），这是一个数据竞争。

那么，如果我们希望两个 goroutine 都在一个包含 s 的初始元素和一个额外元素的切片上工作，我们如何防止数据竞争的发生呢？一种解决方案是创建 `s` 的副本：

```go
s := make([]int, 0, 1)

go func() {
    sCopy := make([]int, len(s), cap(s))
    copy(sCopy, s)

    s1 := append(sCopy, 1)
    fmt.Println(s1)
}()

go func() {
    sCopy := make([]int, len(s), cap(s))
    copy(sCopy, s)

    s2 := append(sCopy, 1)
    fmt.Println(s2)
}()
```

两个 goroutine 都首先制作切片的副本。然后，他们在切片副本上使用 `append`，而不是原始切片。因此，当两个 goroutine 都在隔离数据上工作时，它可以防止发生数据竞争。

> **Note** 数据竞争对切片和地图有多大影响？有多个 goroutine：
> * 访问相同的切片索引，其中至少有一个更新值是数据竞争。事实上，goroutine 正在访问相同的内存位置。
> * 无论操作如何访问不同的切片索引都不是数据竞争；不同的索引意味着不同的内存位置。
> * 访问相同的 map（无论它是相同的还是不同的密钥）并且至少有一个更新它是一场数据竞争。我们可能想知道为什么它与切片数据结构不同？正如我们在数据类型一章中提到的，map 是一个桶数组，每个桶都是一个指向键/值对数组的指针。哈希算法用于确定桶的数组索引。由于此算法在映射初始化期间包含一些随机性，因此一次执行可能会导致相同的数组索引，而另一次执行可能不会。竞争检测器通过发出警告来处理这种情况，而不管实际的数据竞争是否发生。

在并发上下文中使用切片时，我们必须记住，在切片上使用 `append` 并不总是无竞争的。根据切片以及它是否已满，行为会发生变化。如果切片已满，则 `append` 将是无竞争的。否则，多个 goroutine 可能会竞争更新相同的数组索引，从而导致数据竞争。

一般来说，我们不应该根据切片是否已满而有不同的实现。我们应该考虑在并发应用程序中对共享切片使用 `append` 可能会导致数据竞争。因此，应该避免。

现在让我们讨论一个在切片和映射之上不准确的互斥锁的常见错误。