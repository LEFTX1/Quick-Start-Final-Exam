- [[#String 类型内部实现|String 类型内部实现]]
	- [[#String 类型内部实现#一句话总结sds|一句话总结sds]]
- [[#List 类型内部实现|List 类型内部实现]]
	- [[#List 类型内部实现#**Ziplist 的遍历与工作机制总结：**|**Ziplist 的遍历与工作机制总结：**]]
	- [[#List 类型内部实现#一句话总结ziplist：|一句话总结ziplist：]]
	- [[#List 类型内部实现#一句话总结连锁更新问题：|一句话总结连锁更新问题：]]
- [[#Hash 类型内部实现|Hash 类型内部实现]]
	- [[#Hash 类型内部实现#一句话总结dict工作原理:|一句话总结dict工作原理:]]
	- [[#Hash 类型内部实现#一句话总结dict哈希表的渐进更新:|一句话总结dict哈希表的渐进更新:]]
	- [[#Hash 类型内部实现#一句话总结为什么listpack可以删除这个字段:|一句话总结为什么listpack可以删除这个字段:]]
	- [[#Hash 类型内部实现#一句话总结为什么redis要用listpack代替压缩列表，删除了前一个元素长度的字段:|一句话总结为什么redis要用listpack代替压缩列表，删除了前一个元素长度的字段:]]
- [[#Set 类型内部实现|Set 类型内部实现]]
	- [[#Set 类型内部实现#一句话总结set的intset实现：|一句话总结set的intset实现：]]
- [[#ZSet 类型内部实现|ZSet 类型内部实现]]
	- [[#ZSet 类型内部实现#Redis的单线程模式|Redis的单线程模式]]
	- [[#ZSet 类型内部实现#Redis为何采用单线程模式？|Redis为何采用单线程模式？]]
	- [[#ZSet 类型内部实现#Redis 6.0之后的多线程特性|Redis 6.0之后的多线程特性]]
	- [[#ZSet 类型内部实现#线程配置建议|线程配置建议]]
- [[#一句话总结redis线程模型：|一句话总结redis线程模型：]]
	- [[#一句话总结redis线程模型：#1. **AOF日志（Append-Only File）**|1. **AOF日志（Append-Only File）**]]
		- [[#1. **AOF日志（Append-Only File）**#aof重写机制|aof重写机制]]
	- [[#一句话总结redis线程模型：#一句话总结AOF重写机制|一句话总结AOF重写机制]]
		- [[#一句话总结AOF重写机制#主线程为什么要写进两个缓冲区？|主线程为什么要写进两个缓冲区？]]
			- [[#主线程为什么要写进两个缓冲区？#**一个写进老文件一个用于最终合并新文件？**|**一个写进老文件一个用于最终合并新文件？**]]
				- [[#**一个写进老文件一个用于最终合并新文件？**#ChatGPT said:|ChatGPT said:]]
	- [[#一句话总结redis线程模型：#2. **RDB快照**|2. **RDB快照**]]
		- [[#2. **RDB快照**#写时复制（COW）在 `bgsave` 中的运作过程|写时复制（COW）在 `bgsave` 中的运作过程]]
	- [[#一句话总结redis线程模型：#`save` 和 `bgsave` 的本质区别|`save` 和 `bgsave` 的本质区别]]
				- [[#**一个写进老文件一个用于最终合并新文件？**#ChatGPT said:|ChatGPT said:]]
		- [[#`save` 和 `bgsave` 的本质区别#**恢复速度快但可能丢失部分数据**|**恢复速度快但可能丢失部分数据**]]
				- [[#**一个写进老文件一个用于最终合并新文件？**#ChatGPT said:|ChatGPT said:]]
	- [[#一句话总结redis线程模型：#3. **混合持久化**|3. **混合持久化**]]
		- [[#3. **混合持久化**#这里具体说一说：**混合持久化结合AOF的高可靠性和RDB的快速恢复优势，将内存数据和增量操作记录在同一文件中，实现了数据安全性和恢复效率的平衡。**|这里具体说一说：**混合持久化结合AOF的高可靠性和RDB的快速恢复优势，将内存数据和增量操作记录在同一文件中，实现了数据安全性和恢复效率的平衡。**]]
				- [[#**一个写进老文件一个用于最终合并新文件？**#ChatGPT said:|ChatGPT said:]]
		- [[#3. **混合持久化**#再通俗易懂的解释一下：**内存中的全量数据按RDB格式写入AOF文件的前半部分，然后在后半部分使用AOF格式记录从快照生成后发生的增量操作。**|再通俗易懂的解释一下：**内存中的全量数据按RDB格式写入AOF文件的前半部分，然后在后半部分使用AOF格式记录从快照生成后发生的增量操作。**]]
				- [[#**一个写进老文件一个用于最终合并新文件？**#ChatGPT said:|ChatGPT said:]]
			- [[#再通俗易懂的解释一下：**内存中的全量数据按RDB格式写入AOF文件的前半部分，然后在后半部分使用AOF格式记录从快照生成后发生的增量操作。**#You said:|You said:]]
				- [[#You said:#ChatGPT said:|ChatGPT said:]]
- [[#一句话总结redis持久化：|一句话总结redis持久化：]]

# 数据结构
![[Pasted image 20241024180445.png]]

##  String 类型内部实现

String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
- **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

### 一句话总结sds
==通过使用len字段标识来指示字符串长度，而不是通过c语言原生的转义字符标识字符串结束，这样就做到了二进制储存安全，字符不会被当做结束标志，并且获取长度可以直接读取len字段，复杂度为O1.SDS 在执行字符串拼接或追加操作前会自动检查空间是否足够，如果不足则自动扩容，确保不会发生缓冲区溢出。==



##  List 类型内部实现

List 类型的底层数据结构是由**双向链表或压缩列表**实现的：

- 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用**压缩列表**作为 List 类型的底层数据结构；
- 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构；

但是**在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。
![[Pasted image 20241024181500.png]]

### **Ziplist 的遍历与工作机制总结：**

1. **Ziplist 是一种紧凑的连续内存结构**，每个元素（Entry）都按顺序存储在一块连续的内存中。它的设计通过 **偏移量** 实现了类似双向链表的功能，但避免了指针的内存开销。
    
2. **向后遍历（从头到尾）：**
    
    - 读取当前节点的 **`encoding` 字段**，解析出当前节点的类型和长度。
    - 根据解析出的长度，**直接跳转到下一个节点** 的起始位置。
3. **向前遍历（从尾到头）：**
    
    - 读取当前节点的 **`previous_entry_length` 字段**，获取上一个节点的长度。
    - 利用当前节点的起始位置，向前移动相应的字节数，**跳转到上一个节点**。
4. **设计的优势：**
    
    - **节省内存**：没有传统双向链表的指针，减少了内存碎片和开销。
    - **高效遍历**：向前和向后的遍历都能在 $O(1)$ 时间内完成。
    - **灵活存储**：支持不同类型的数据（如字符串和整数），并使用合适的编码压缩存储。
5. **缺点：**
    
    - 由于每次插入、删除可能引发 **连锁更新**（需要调整后续节点的 `previous_entry_length`），在某些情况下会影响性能。

### 一句话总结ziplist：
==Ziplist 利用 **偏移量代替指针** 实现了高效的双向遍历，并通过 指定编码得知当前节点长度**encoding 和 previous_entry_length**上一个元素长度的两个 字段，确保向前和向后遍历都能快速完成，向后遍历就走当前编码长度，向前遍历就走上一个元素的长度的步数，是 Redis 在节省内存和保持性能上的一种巧妙设计。==


### 一句话总结连锁更新问题：
连锁更新问题 是由于 前一个节点长度变化 需要不断调整 后续节点的 previous_entry_length 字段，而后续节点的 previous_entry_length 字段可能也需要扩容，导致连锁反应


## Hash 类型内部实现

Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：

- 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；
- 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的底层数据结构。

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。
![[Pasted image 20241024192023.png]]


### 一句话总结dict工作原理:
"通过哈希函数将键映射到数组的对应下标位置，若出现哈希冲突，则采用链表将冲突的键值对串联起来。"

### 一句话总结dict哈希表的渐进更新:
Redis 的渐进式 Rehash 通过在常规操作（如插入、删除、查询）过程中，将旧数组中的元素按顺序逐步迁移到新数组，每次操作完成部分数据迁移，避免一次性重建导致的阻塞，确保系统性能的平稳运行。

### 一句话总结为什么listpack可以删除这个字段:
Redis 认为在 **小型数据集** 上，牺牲向前遍历带来的性能优势，换取 **避免连锁更新** 和 **更稳定的系统性能**，是更有性价比的设计选择。


### 一句话总结为什么redis要用listpack代替压缩列表，删除了前一个元素长度的字段:
“由于 Ziplist 中的连锁更新可能将原本 $O(1)$ 的操作恶化为 $O(n)$，导致性能问题，并且其触发机制如同黑箱，开发者难以预测；当小型数据量批量增多时，Redis 会在某些数据结构中自动使用压缩列表，频繁操作这些结构会增加连锁更新的可能性，意味着业务规模越大，性能问题出现的风险越高。因此，Redis 用 Listpack 代替 Ziplist，删除了 `previous_entry_length` 字段，以避免连锁更新，提升系统的稳定性和性能。”

## Set 类型内部实现

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

- **小数据量**：如果所有元素都是整数且数量 **小于 512**（默认值，可配置为 `set-maxintset-entries`），Redis 使用 **Intset** 存储，节省内存。
    
- **大数据量或非整数元素**：如果元素数量超过阈值或包含非整数，Redis 自动切换为 **哈希表** 实现，确保操作性能。


### 一句话总结set的intset实现：
Redis 的整数集合（Intset）本质上是一个有序数组，通过二分查找避免重复，并在插入、删除时移动数组元素来模拟 Set 的行为，适用于小规模整数集合。


## ZSet 类型内部实现

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

![[Pasted image 20241024202411.png]]

#   Redis是否单线程？

Redis被称为单线程，因为它的请求处理过程（接收请求、解析请求、执行读写操作、发送响应）是由一个主线程完成的。然而，Redis并不完全是单线程的。自2.6版本起，Redis会启动后台线程（BIO）来处理一些耗时的任务，如关闭文件和AOF刷盘。4.0版本之后，还引入了一个线程用于异步释放内存（lazyfree），从而避免主线程在处理大key删除时的卡顿。

### Redis的单线程模式

在Redis 6.0之前，主线程通过事件循环处理网络I/O和命令执行。它的主要流程包括：

1. 初始化epoll对象和服务端socket。
2. 注册连接事件处理函数并进入事件循环。
3. 处理发送队列、连接事件、读事件和写事件。

### Redis为何采用单线程模式？

1. **性能瓶颈**：Redis的性能瓶颈主要在内存和网络I/O，而不是CPU，因此采用单线程模式不会影响性能。
2. **简化设计**：单线程模型降低了并发读写导致的复杂性，避免了线程竞争、切换和死锁等问题。
3. **I/O多路复用**：单线程能够有效处理多个客户端请求。

### Redis 6.0之后的多线程特性

在Redis 6.0中，为了提高网络I/O的并行度，引入了多线程处理网络请求，但命令执行仍然保持单线程。该版本的I/O多线程特性能够显著提升性能，尤其是在处理发送响应时。若要启用对读请求的多线程处理，需要在配置文件中设置相关选项。

### 线程配置建议

- 对于4核CPU，建议使用2-3个I/O线程；对于8核CPU，建议使用6个线程。
- Redis会在启动时创建多个线程：主线程、3个后台线程和I/O线程（根据配置数量而定）。

这种设计使得Redis在保证高性能的同时，能够灵活应对高并发的网络请求。


## 一句话总结redis线程模型：
Redis主要使用单线程处理请求，依靠事件循环不断从任务队列中取出并处理每个事件，以及利用I/O多路复用，一个线程同时管理多个网络连接，实现高并发，同时通过后台线程处理耗时任务，比如关闭文件、AOF刷盘和异步释放内存等以避免主线程阻塞。



# Redis 持久化
### 1. **AOF日志（Append-Only File）**

- 每次执行写操作时将命令追加到日志文件中，重启时重放日志恢复数据。
- 优点：数据丢失少。
- 缺点：恢复速度较慢，日志文件会越来越大，**需定期重写日志文件。**

#### aof重写机制
Redis的AOF重写机制旨在控制AOF文件大小，避免文件过大影响性能。具体步骤包括：
1. **触发条件**：当AOF文件大小超过预设阈值，Redis会启用AOF重写机制，将当前数据库中所有键值对重新写入到新的AOF文件，以“压缩”文件体积。
2. **重写过程**：
    - Redis会启动一个子进程(`bgrewriteaof`)完成重写，以避免阻塞主进程。子进程会读取数据库中的所有数据，将每个键值对转化成单条命令写入新的AOF文件。例如，如果多次修改了同一个键，仅记录最后一次更新的结果。
    - 子进程采用写时复制(Copy-On-Write)技术，共享父进程的内存数据的副本，因此即使在重写过程中数据发生变化也不会影响数据一致性。
3. **双缓冲区**：在重写期间，为保证数据一致性，Redis设置了一个AOF重写缓冲区。主进程会将所有写操作同时写入AOF缓冲区（用于正常AOF记录）和AOF重写缓冲区（确保新旧AOF文件一致）。
4. **重写完成**：当子进程完成重写后，向主进程发送信号，主进程将AOF重写缓冲区内容追加到新的AOF文件中，然后用新的AOF文件替换旧文件，确保持久化数据一致性。

### 一句话总结AOF重写机制
子进程利用当时的内存快照快速重写所有aof命令，主进程的新更改记录到缓存区，在子进程完成后合并文件？

#### 主线程为什么要写进两个缓冲区？
主线程写入两个缓冲区（AOF缓冲区和AOF重写缓冲区）主要是为了确保数据的一致性和连续性，避免数据丢失。具体来说：

1. **AOF缓冲区**：这个缓冲区用于当前的旧AOF文件，它保证即使Redis在重写过程中发生故障或崩溃，仍然能通过旧AOF文件中的记录恢复数据。主线程在重写期间仍会更新旧的AOF文件，以保证数据的完整性。
    
2. **AOF重写缓冲区**：这个缓冲区专门为新的AOF文件而设，记录子进程重写AOF时主线程执行的增量命令。因为子进程在开始重写时已经读取了内存快照，但之后的数据变化不会体现在新文件中。所以，重写缓冲区确保这些新命令可以在子进程完成重写后合并到新的AOF文件中，保证新旧文件一致性。

##### **一个写进老文件一个用于最终合并新文件？**
###### ChatGPT said:
没错，正是这样！

- **AOF缓冲区**：主线程将新命令写入这个缓冲区，用于更新**当前的旧AOF文件**。即使在AOF重写过程中发生故障或意外重启，旧AOF文件中的记录依然可以恢复数据。
    
- **AOF重写缓冲区**：主线程同时将新命令写入这个缓冲区，以便在子进程完成重写后，将重写期间的增量命令**合并到新的AOF文件**中，从而保证新文件包含最新的所有数据。
    

这种设计确保了数据在重写过程中不会丢失，并且最终生成的新AOF文件是最新且完整的。



### 2. **RDB快照**

- 定期生成某一时刻的内存快照并保存到磁盘，快照过程通过子进程进行，避免阻塞主线程。
- 优点：恢复速度快，占用存储空间小。
- 缺点：**快照频率较低时数据丢失多，频率高则影响性能。**


#### 写时复制（COW）在 `bgsave` 中的运作过程
### `save` 和 `bgsave` 的本质区别

- **`save` 命令**：在主线程中直接执行快照生成，会导致 Redis 暂停所有操作并阻塞主线程，直到快照写入完成。因为它在主线程中操作，`save` 会导致 Redis 短暂停止服务，所以一般在性能要求不高的情况下才使用。
    
- **`bgsave` 命令**：创建一个子进程进行快照生成，主线程不会被阻塞，因此可以继续处理其他请求，保证服务不中断。利用 COW 技术，主进程的修改不会影响子进程的数据读取，从而保证了快照的一致性。由于 `bgsave` 的非阻塞特性，通常在生产环境中使用。


**也就是父子进程通过页表虚拟内存映射到同一块物理地址，在主进程修改后，会将新数据放到新的物理地址并且修改页表映射到新地址，旧地址和旧数据仍然给子进程读取使用？**

###### ChatGPT said:
是的，正是如此！

在 `bgsave` 执行时，Redis 通过 `fork()` 创建的子进程和主进程共享同一块物理内存。这是通过页表的虚拟内存映射实现的，即父子进程的页表映射到同一个物理地址。

当主进程修改数据时，操作系统通过写时复制（COW）机制，让主进程将新数据写入一个新的物理地址，并更新主进程的页表，将修改后的虚拟地址映射到新地址。与此同时，子进程的页表仍然映射到原来的物理地址，因此子进程继续读取未修改的旧数据，不受影响。

这样，父子进程在 `bgsave` 期间对数据的操作是相互独立的。主进程可以继续修改数据，而子进程能够确保快照的数据一致性。

#### **恢复速度快但可能丢失部分数据**
###### ChatGPT said:
在Redis的持久化机制中，RDB快照通过定期将内存中的数据快照保存到磁盘，生成一个包含所有数据的二进制文件。这种方式的恢复速度快，因为在恢复时只需将整个RDB文件一次性加载到内存即可，不需要像AOF那样逐条执行命令日志，节省了重放时间。
但由于RDB的保存是周期性的（例如每隔几分钟或每小时），如果Redis在下次快照之前发生故障，期间的新增或更改数据将无法恢复。因此，使用RDB快照会带来丢失最近一次快照后写入的数据的风险，具体丢失量取决于快照的频率设置。

### 3. **混合持久化**

- Redis 4.0引入，将RDB的全量数据和AOF的增量数据整合在一个AOF文件中。
- 优点：结合了RDB恢复速度快和AOF数据丢失少的优点。
- 缺点：**AOF文件可读性差**，仅支持Redis 4.0及以上版本。

#### 这里具体说一说：**混合持久化结合AOF的高可靠性和RDB的快速恢复优势，将内存数据和增量操作记录在同一文件中，实现了数据安全性和恢复效率的平衡。**
###### ChatGPT said:
混合持久化是Redis 4.0引入的一种持久化方式，结合了AOF和RDB的优点，以达到数据安全性和恢复效率的平衡。具体来说，混合持久化在**重写AOF文件**时，先将**内存中的全量数据按RDB格式写入AOF文件的前半部分，然后在后半部分使用AOF格式记录从快照生成后发生的增量操作。**
这样做的优势在于：
1. **快速恢复**：重启时，Redis先加载AOF文件的前半部分（RDB格式），将数据一次性恢复到最后一次重写的状态，这一步比逐条执行命令日志快得多。
2. **减少数据丢失**：后半部分的AOF增量记录保存了快照后发生的操作，确保数据不会丢失太多。
3. **统一持久化文件**：混合持久化文件兼具RDB和AOF优点，数据恢复速度快，且丢失数据量比单独使用RDB少，最终文件大小也更可控。

因此，混合持久化让Redis能够更快速地加载数据，同时降低了数据丢失的风险，是高性能和数据持久性需求间的折衷方案。

#### 再通俗易懂的解释一下：**内存中的全量数据按RDB格式写入AOF文件的前半部分，然后在后半部分使用AOF格式记录从快照生成后发生的增量操作。**
###### ChatGPT said:
在混合持久化中，Redis将内存里的所有数据“打包”成一个快照（RDB格式），并把这个完整的快照内容写在AOF文件的开头部分。这样，Redis重启时可以一次性加载这个快照，大大加快恢复速度。

随后，Redis会记录从这个快照生成之后发生的每个修改操作（增量操作）并以AOF格式追加在文件的后半部分。这样一来，AOF文件包含了两部分内容：

1. **前半部分**：一次性保存的“快照”，代表Redis内存中当时的所有数据状态。
2. **后半部分**：记录快照生成后发生的所有修改，保证这些新数据也能恢复。

这种方式结合了两种方式的优势：前面的快照让数据恢复更快，后面的增量记录让数据丢失更少。
##### You said:
我懂了，就是在原本rdb定期任务的间隔内执行aof记录
###### ChatGPT said:
对的，正是这样！混合持久化的核心思路就是在RDB快照的基础上加入AOF记录，把RDB快照生成后的每一步改动都记录下来，这样可以弥补快照间隔内的数据空缺。

因此，通过这种方式，Redis可以利用RDB的快速恢复特性，同时降低AOF模式下可能的数据丢失风险，实现了两者的优势结合。


## 一句话总结redis持久化：
“Redis持久化主要有三种方式：AOF日志、RDB快照和混合持久化。AOF日志方式就是在**每次写操作后**将**操作命令**追加到**日志文件**，重启时利用记录的命令日志恢复数据；RDB快照**定期将内存数据快照保存到磁盘**，恢复速度快但可能丢失部分数据；混合持久化结合AOF的高可靠性和RDB的快速恢复优势，将内存数据和增量操作记录在同一文件中，实现了数据安全性和恢复效率的平衡。”


