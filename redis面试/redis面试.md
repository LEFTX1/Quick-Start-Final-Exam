
# 数据结构
![[Pasted image 20241024180445.png]]

##  String 类型内部实现

String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
- **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

### 一句话总结sds
==通过使用len字段标识来指示字符串长度，而不是通过c语言原生的转义字符标识字符串结束，这样就做到了二进制储存安全，字符不会被当做结束标志，并且获取长度可以直接读取len字段，复杂度为O1.SDS 在执行字符串拼接或追加操作前会自动检查空间是否足够，如果不足则自动扩容，确保不会发生缓冲区溢出。==



##  List 类型内部实现

List 类型的底层数据结构是由**双向链表或压缩列表**实现的：

- 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用**压缩列表**作为 List 类型的底层数据结构；
- 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构；

但是**在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。
![[Pasted image 20241024181500.png]]

### **Ziplist 的遍历与工作机制总结：**

1. **Ziplist 是一种紧凑的连续内存结构**，每个元素（Entry）都按顺序存储在一块连续的内存中。它的设计通过 **偏移量** 实现了类似双向链表的功能，但避免了指针的内存开销。
    
2. **向后遍历（从头到尾）：**
    
    - 读取当前节点的 **`encoding` 字段**，解析出当前节点的类型和长度。
    - 根据解析出的长度，**直接跳转到下一个节点** 的起始位置。
3. **向前遍历（从尾到头）：**
    
    - 读取当前节点的 **`previous_entry_length` 字段**，获取上一个节点的长度。
    - 利用当前节点的起始位置，向前移动相应的字节数，**跳转到上一个节点**。
4. **设计的优势：**
    
    - **节省内存**：没有传统双向链表的指针，减少了内存碎片和开销。
    - **高效遍历**：向前和向后的遍历都能在 $O(1)$ 时间内完成。
    - **灵活存储**：支持不同类型的数据（如字符串和整数），并使用合适的编码压缩存储。
5. **缺点：**
    
    - 由于每次插入、删除可能引发 **连锁更新**（需要调整后续节点的 `previous_entry_length`），在某些情况下会影响性能。

### 一句话总结ziplist：
==Ziplist 利用 **偏移量代替指针** 实现了高效的双向遍历，并通过 指定编码得知当前节点长度**encoding 和 previous_entry_length**上一个元素长度的两个 字段，确保向前和向后遍历都能快速完成，向后遍历就走当前编码长度，向前遍历就走上一个元素的长度的步数，是 Redis 在节省内存和保持性能上的一种巧妙设计。==


### 一句话总结连锁更新问题：
连锁更新问题 是由于 前一个节点长度变化 需要不断调整 后续节点的 previous_entry_length 字段，而后续节点的 previous_entry_length 字段可能也需要扩容，导致连锁反应


## Hash 类型内部实现

Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：

- 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；
- 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的底层数据结构。

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。
![[Pasted image 20241024192023.png]]


### 一句话总结dict工作原理:
"通过哈希函数将键映射到数组的对应下标位置，若出现哈希冲突，则采用链表将冲突的键值对串联起来。"

### 一句话总结dict哈希表的渐进更新:
Redis 的渐进式 Rehash 通过在常规操作（如插入、删除、查询）过程中，将旧数组中的元素按顺序逐步迁移到新数组，每次操作完成部分数据迁移，避免一次性重建导致的阻塞，确保系统性能的平稳运行。

### 一句话总结为什么listpack可以删除这个字段:
Redis 认为在 **小型数据集** 上，牺牲向前遍历带来的性能优势，换取 **避免连锁更新** 和 **更稳定的系统性能**，是更有性价比的设计选择。


### 一句话总结为什么redis要用listpack代替压缩列表，删除了前一个元素长度的字段:
“由于 Ziplist 中的连锁更新可能将原本 $O(1)$ 的操作恶化为 $O(n)$，导致性能问题，并且其触发机制如同黑箱，开发者难以预测；当小型数据量批量增多时，Redis 会在某些数据结构中自动使用压缩列表，频繁操作这些结构会增加连锁更新的可能性，意味着业务规模越大，性能问题出现的风险越高。因此，Redis 用 Listpack 代替 Ziplist，删除了 `previous_entry_length` 字段，以避免连锁更新，提升系统的稳定性和性能。”

## Set 类型内部实现

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

- **小数据量**：如果所有元素都是整数且数量 **小于 512**（默认值，可配置为 `set-maxintset-entries`），Redis 使用 **Intset** 存储，节省内存。
    
- **大数据量或非整数元素**：如果元素数量超过阈值或包含非整数，Redis 自动切换为 **哈希表** 实现，确保操作性能。


### 一句话总结set的intset实现：
Redis 的整数集合（Intset）本质上是一个有序数组，通过二分查找避免重复，并在插入、删除时移动数组元素来模拟 Set 的行为，适用于小规模整数集合。


## ZSet 类型内部实现

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

![[Pasted image 20241024202411.png]]

#   Redis 线程模型





