

# 黑马点评

### **技术架构**: Kratos + Mysql + Redis + gen

**项目简介**: 一个以用户点评为主要内容的本地生活服务平台。实现了登录注册、点赞排行，发布博客，好友关注，优惠卷秒杀，用户签到等功能。用户在通过短信登录之后，可以给别人的帖子点赞，关注别人，也可以查询附近商户，抢优惠卷，在体验完之后可以发表对于该商户的评价贴，同时还实现了用户的签到功能，增加用户的粘性和活跃度

### **我负责的部分**:

- **登录注册**: 对于用户提交的信息使用**Validation**校验，并使用Redis实现验证码、Token的存储
- **热点数据缓存**: Redis+Caffeine实现应用层二级缓存，对于经常访问而且不易变化的数据进行缓存
- **点赞与关注**: 使用**ZSet数据结构**实现了**点赞排行榜**功能，用**Set**以及**集合运算**实现**关注和共同关注**功能，用**Feed流**实现**关注推送**功能
- **优惠券秒杀**: 使用**Lua脚本**解决集群模式下一人一单的问题，**乐观锁**解决库存超卖问题

## **开发中遇到的问题以及最终解决方案**:

1. **Token刷新问题**: 搭建拦截器链，用一级拦截器完成用户的登录校验、并使用二级拦截器解决Token刷新的问题，实现了只要用户在使用就会一直刷新Token的效果
2. **用户权限保存问题**: 通过**context**配合拦截器来进行**Token令牌**的校验，判断当前用户是否处于登录状态，解决了HTTP无状态的问题
3. **Session集群共享问题**: 在集群环境中，服务器之间无法实现会话状态的共享，本项目采用**Redis缓存用户信息**，解决了**原生session**的**痛点**
4. **缓存一致性问题**: 在系统中采用超时剔除和主动更新的缓存更新方案，满足较高的数据一致性需求
5. **ID的规律性明显问题**: 使用自定义分布式ID，通过时间截+序列号+数据库自增的方式实现
6. **秒杀性能优化**: Redis-**Stream流**实现消息队列+Lua脚本实现**异步处理下单**流程，将同步下单改为异步下单，**优化了秒杀业务的流程**，通过JMeter性能压测发现平均耗时从300ms左右降低到100ms左右
7. **高并发问题**: 使用Redis对高频访问的信息进行**缓存预热**，用**布隆过滤器**解决**缓存穿透**，用**随机TTL**解决缓存雪崩，用**逻辑过期**解决**缓存击穿**

在现代Web应用中，用户登录后的会话管理有两种常见方案：**基于Redis的Session方案**和**基于JWT的无状态认证方案**。两者各有优劣，适用于不同的实际场景。

### 1. **Redis替代Session的登录方案**

#### 工作机制：

- 传统的Session机制是将用户的会话数据存储在服务器内存中，用户登录成功后，服务器会生成一个Session ID，客户端通过Cookie携带Session ID，在每次请求时带上该Session ID，服务器通过Session ID找到对应的会话数据。
- 使用Redis替代传统的Session机制时，用户的Session数据不再存储在单个服务器内存中，而是存储在分布式缓存Redis中。每次请求时，通过Session ID查找Redis中的会话数据。

#### 优点：

1. **会话共享（集群支持）**：
    
    - 在分布式系统中，当多个应用实例需要共享用户会话数据时，Redis可以作为集中式的会话存储，使所有实例共享同一个用户Session。
    - 适用于多节点的集群环境，避免了单一服务器无法共享Session导致的用户频繁登录问题。
2. **灵活的会话管理**：
    
    - Redis支持设置会话过期时间，且可以通过Redis TTL机制灵活地管理Session过期。管理员也可以轻松地从Redis中删除某个用户的会话，强制用户退出登录。
3. **高并发支持**：
    
    - Redis具备高性能和高并发处理能力，尤其适合需要快速读写的会话管理场景。比起传统的基于内存的Session，Redis具备更好的扩展性，能处理大规模用户并发访问。
4. **持久化和容灾能力**：
    
    - Redis可以通过AOF（Append Only File）或RDB（Redis数据备份）等机制实现会话数据的持久化，即使Redis宕机，也可以恢复大部分会话数据。
    - Redis还支持主从同步、哨兵模式等，具备较强的容灾能力。

#### 缺点：

1. **依赖外部存储**：
    
    - 系统对于Redis的依赖较高。如果Redis服务不可用，用户会话会全部失效，导致用户无法访问应用。需要在生产环境中配备高可用的Redis集群来保障系统稳定性。
2. **有状态管理**：
    
    - 使用Session的方案是**有状态**的，需要在Redis中存储用户的状态信息。由于需要频繁读写Redis，可能### 5. **混合方案：JWT + Redis**

有些系统为了兼顾**灵活性**和**安全性**，会采用**JWT + Redis**的混合方案。通过这种方式，可以在享受JWT的无状态优势的同时，解决一些JWT方案中的安全问题和缺陷。

#### 工作机制：

1. **JWT的无状态认证**：
    
    - 用户登录后，服务器生成JWT Token，Token中包含用户身份信息和有效期，客户端持有Token并在后续请求中携带该Token进行认证。
    - 服务器无需存储任何与Token相关的状态，所有验证信息都包含在Token本身。
2. **Redis的状态控制**：
    
    - 尽管JWT是无状态的，但为了增强安全性，可以将JWT的**唯一标识符（如JTI，JWT ID）**或**黑名单信息**存储在Redis中，以便更灵活地管理Token的生命周期。
    - 通过Redis，可以解决JWT的两个主要问题：**Token的失效控制**和**Token的刷新管理**。

#### 优点：

- **灵活性**：
    
    - 使用JWT的无状态特性，用户可以在不同的服务或API之间携带Token进行认证，无需共享会话信息，适合微服务和跨系统认证场景。
- **安全性增强**：
    
    - 通过在Redis中存储Token的唯一标识符（如JTI），可以在需要时强制失效某个Token。这种机制可以解决JWT天然无法主动失效的问题。例如，当用户注销、Token被泄露或管理员强制登出某些用户时，可以在Redis中将该Token标记为失效，后续任何请求带上该Token时，系统都会拒绝。
- **支持Token刷新**：
    
    - 通过Redis，可以支持JWT Token的**自动刷新机制**。当用户的Token接近过期时，系统可以根据Redis中的Token信息生成一个新的Token，并刷新Token的有效期。这可以保持用户的登录状态，同时避免频繁让用户重新登录。
- **会话与权限变更实时性**：
    
    - 在一些场景中，用户的权限可能发生变化（例如，管理员升级或降级用户权限），这种变化可以存储在Redis中。在每次请求时，系统可以检查Redis中的最新权限信息，确保权限变更可以实时生效，而不是等到Token过期。

#### 缺点：

- **复杂度增加**：
    
    - 引入Redis后，系统变得稍微复杂，需要额外的Redis服务来管理Token信息。尤其是在高并发场景下，Redis可能成为新的性能瓶颈，需要合理配置Redis的容量和访问频率。
- **有状态与无状态混合**：
    
    - 虽然JWT本身是无状态的，但通过Redis来管理Token的状态，这意味着引入了“伪无状态”机制。系统在每次请求中，可能还需要访问Redis来验证Token的有效性，这降低了无状态的纯粹性。

#### 实际场景：

- **高安全性要求的分布式系统**：
    
    - 在一些金融、企业级应用中，用户登录后的安全性要求很高，而仅依赖JWT可能存在Token泄露的风险。通过Redis，可以增强对Token的控制，实现更灵活的安全管理。
- **需要Token失效控制的系统**：
    
    - 如果系统中有大量用户，同时需要提供即时的注销或强制登出功能（比如后台管理系统需要实时控制某些用户的登录状态），可以借助Redis来存储和管理Token的状态信息。
- **Token刷新和长期登录的场景**：
    
    - 某些应用要求用户保持较长时间的登录状态，但直接使用JWT的长期有效期可能不安全。通过结合Redis，可以实现短期Token+自动刷新机制，用户在Token接近过期时，后台可以自动生成新的Token，减少用户的重新登录操作。对性能产生一定的压力，尤其是在高并发或频繁登录退出的场景中。
3. **存储开销**：
    
    - Redis中的会话数据占用了额外的内存资源，随着用户量的增长，Redis的存储压力也会增大。如果用户会话管理不当，可能导致Redis内存占用过大，影响系统性能。

#### 实际场景：

- **适合需要会话共享的场景**：
    - 比如社交网站、企业级SaaS应用等，在多个应用实例中需要频繁登录的场景。Redis可以提供集中化的会话管理，支持集群扩展，保障用户体验一致。
- **高频访问的电商网站**：
    - Redis方案更适合需要高频访问且支持高并发登录访问的场景，如电商促销期间的秒杀活动中，Redis能有效管理会话，确保用户在不同服务器实例间会话一致性。

---

### 2. **JWT（JSON Web Token）签发方案**

#### 工作机制：

- JWT是一种**无状态**的认证机制。用户登录成功后，服务器生成一个JWT Token，其中包含用户的身份信息和加密签名，发送给客户端。客户端每次请求时将Token放入请求头中，服务器验证Token的合法性和签名是否正确即可确认用户身份，不需要存储会话数据。

#### 优点：

1. **无状态**：
    
    - JWT是无状态的，不需要在服务器端存储用户的任何状态信息。认证信息全部包含在Token中，服务器只需要校验Token的签名即可确认用户身份。
    - 适用于分布式、微服务架构，多个服务节点之间无需共享用户状态。
2. **更好的扩展性**：
    
    - 由于服务器不需要存储会话数据，JWT非常适合分布式和微服务环境，不需要维护统一的会话存储，减少了对外部存储（如Redis）的依赖，系统可以随时扩展新的节点。
3. **便携性**：
    
    - JWT可以在客户端存储，甚至可以跨域或跨系统传递，具备很好的便携性。不同服务或API之间可以使用相同的Token来完成用户的身份验证。
4. **自带签名和安全性**：
    
    - JWT内置了加密签名，可以防止篡改。即使客户端可以看到Token的内容，签名部分也保证了数据的完整性和安全性。只要不泄露密钥，用户不能伪造或篡改JWT。

#### 缺点：

1. **安全风险**：
    
    - JWT是无状态的，一旦生成，服务器无法单方面将其作废。因此，如果Token被泄露，攻击者可以一直使用该Token，直到它过期。虽然可以缩短Token的有效期，但这会增加用户的重新登录频率。
2. **Token长度**：
    
    - JWT通常比较大（尤其是包含较多用户信息的情况下），每次请求都需要携带该Token，可能增加HTTP请求的大小，导致带宽消耗增加。
3. **难以控制Token失效**：
    
    - 由于JWT是自包含的，无状态特性意味着很难在服务器端直接控制某个Token的失效。要主动让某个JWT失效，通常需要引入额外的黑名单机制或者缩短Token有效期。
4. **无法实时更新**：
    
    - JWT一旦签发，内容就无法修改。如果用户的某些权限发生了变化，原来的Token不会立即反映这些变化。除非等待JWT过期并重新生成Token，否则很难做到实时更新。

#### 实际场景：

- **微服务架构**：
    - JWT特别适用于微服务环境下的身份认证场景。比如在多个独立服务之间传递用户身份信息时，JWT可以无缝地进行跨服务身份验证，无需依赖会话状态。
- **跨域或移动端认证**：
    - 在跨域请求中，或者移动应用中，JWT也非常适合。它可以安全地在客户端存储，并在不同系统或服务之间进行身份传递。

---

### 3. **Redis-Session vs JWT 的实际场景优劣对比**

|**特点**|**Redis-Session**|**JWT**|
|---|---|---|
|**状态**|有状态，需要在Redis中存储会话数据|无状态，用户数据包含在Token中，不依赖服务器存储|
|**会话共享**|需要Redis或数据库来共享Session|无需共享，会话数据包含在Token中，可以跨服务传递|
|**安全性**|依赖Redis存储，可以控制会话失效|有被泄露的风险，无法直接失效Token|
|**扩展性**|Redis负载均衡较难，需配置高可用集群|扩展性强，无状态系统，适合分布式和微服务架构|
|**性能**|频繁读取Session时可能增加Redis压力|每次请求携带Token，可能增加请求体大小|
|**适用场景**|适合需要会话共享和控制失效的系统，或需要强一致性|适合分布式、微服务架构，尤其是跨域或跨系统传递身份|

---

### 4. **结合实际场景的选择建议**

1. **适合使用Redis-Session的场景**：
    
    - **传统Web应用**：在用户每次请求都依赖Session并且需要共享会话数据的场景，比如传统的电商网站、企业管理系统，这些系统通常需要较强的会话管理能力。
    - **分布式系统中的用户状态管理**：当你有多个服务实例，但希望在用户跨页面或跨实例时保持一致的登录状态，Redis可以很好的解决这一问题。
2. **适合使用JWT的场景**：
    
    - **微服务架构**：JWT在微服务架构下非常合适，因为其无状态特性减少了各个服务之间对用户状态同步的依赖。
    - **移动应用或API认证**：在移动端或API调用中，JWT因为便携性和无状态特性，可以让客户端更自由地携带Token进行跨域和跨服务的认证。
