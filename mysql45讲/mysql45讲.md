# 04 深入浅出索引 上
### 一、索引的常见模型

1. **哈希表**

    - 结构：键 - 值存储
    - 优点：快速等值查询
    - 缺点：范围查询效率低
    - 适用场景：等值查询
2. **有序数组**
    - 结构：按顺序存储，支持二分查找
    - 优点：高效等值和范围查询，时间复杂度 $O(\log(N))$
    - 缺点：插入操作开销大
    - 适用场景：静态存储（不常修改的数据）
3. **二叉搜索树**
    - 特点：左子树小于父节点，右子树大于父节点
    - 优点：查询和更新时间复杂度 $O(\log(N))$
    - 缺点：树高对查询效率影响，磁盘访问性能差
    - 发展为多叉树（N叉树）以减少磁盘访问

### 二、InnoDB的索引模型

1. **B+树索引**
    
    - 组织方式：主键索引（聚簇索引）与非主键索引（二级索引）
    - 主键索引：叶子节点存储整行数据
    - 非主键索引：叶子节点存储主键值
    - 查询过程：主键索引直接查找，非主键索引需要“回表”
2. **索引维护**
    
    - 插入数据时的页分裂和合并
    - 性能影响与空间利用率
    - 自增主键的优点：减少插入时的移动与分裂

### 三、索引选择原则

- 自增主键 vs 业务字段主键
    - 存储空间与性能的权衡
    - 适用场景的分析

### 四、重建索引

- 主键索引与普通索引重建的注意事项
- 性能影响与最佳实践

### 小结

- 综述B+树索引的性能优越性
- 建议使用自增主键以优化空间和性能
- 留下思考问题，鼓励读者参与讨论

Mysql b+树
![[Pasted image 20240926001539.png]]

# 为什么 innodb 选择 b加树 作为索引结构？
InnoDB存储引擎选择B+树索引的原因主要体现在以下几个方面：

### 1. **搜索效率高**

- **层级较少**：**由于B+树的非叶子节点只存储指针，能够承载更多的子节点，从而使树的高度更低。这意味着在进行查找时，所需的比较次数减少，访问速度更快。**
### 3. **范围查询和排序**
- **叶子节点双向链表**：B+树的叶子节点形成双向链表，这使得范围查询和排序操作更加高效。用户可以在叶子节点中快速遍历数据，适合执行如 `BETWEEN` 和 `ORDER BY` 的查询。
### 4. **更好的空间利用**
- **数据分离**：B+树的叶子节点存储实际数据，而非叶子节点只存储指针，这样可以更有效地利用存储空间。同时，叶子节点的设计使得它们可以有效地填充，从而减少空间浪费。
### 5. **插入和删除操作**

- **平衡性维护**：B+树能够在插入和删除操作后自我平衡，保持树的结构稳定性。这保证了操作的时间复杂度在 `O(log n)` 范围内，适合高并发的数据库环境。

### 6. **对比其他索引结构**

- **与哈希索引的对比**：哈希索引只支持等值匹配，不支持范围查询和排序操作，这限制了其使用场景。而B+树能够处理更多类型的查询，提供更大的灵活性。
# 索引类型
![[Pasted image 20240926002639.png|500]]
![[Pasted image 20240926002812.png|500]]
# 深入浅出索引 下
### 索引深入浅出（下）——大纲和要点总结

#### 1. **基本索引操作过程**

- **问题描述**：在 `select * from T where k between 3 and 5` 查询中，需要几次树的搜索操作？涉及到几次回表操作？
- **示例分析**：
    - 通过 **k 索引树** 定位到 k=3 和 k=5 的记录。
    - 通过主键 ID 进行回表，获取对应的记录数据。
    - 总共涉及 **3 次索引读取** 和 **2 次回表**。

#### 2. **回表与覆盖索引**

- **回表**：在二级索引（非聚簇索引）中，如果需要的字段不在索引中，必须通过主键再次访问主表获取完整数据，这个过程称为 **回表**。
- **覆盖索引**：如果查询所需的字段全部包含在索引中，则可以避免回表直接返回数据。这种情况称为 **覆盖索引**。
    - 优点：减少回表次数，提升查询性能。
    - 示例：`select ID from T where k between 3 and 5` 只需要读取 k 索引上的 ID，不需要回表。

#### 3. **联合索引与冗余索引**

- **问题描述**：是否有必要为市民信息表创建 `(身份证号, 姓名)` 的联合索引？
- **解答**：如果有高频查询是基于 **身份证号查询姓名** 的场景，联合索引有助于覆盖查询，减少回表。然而，建立冗余索引的代价较高，需要根据业务需求权衡是否增加冗余索引。

#### 4. **最左前缀原则**

- **概念**：在联合索引中，B+树索引可以通过 **最左前缀** 来加速检索，即可以使用索引的最左边 N 个字段或最左 M 个字符进行快速定位。
- **示例分析**：
    - 联合索引 `(name, age)` 可以用于 `where name = '张三'` 的查询，也可以用于 `where name like '张%'` 的范围查询。
    - **字段顺序的设计**：如果一个联合索引能够通过调整字段顺序减少索引维护成本，那么应优先考虑这一调整。比如 `(name, age)` 索引可以加速基于 `name` 的查询，不必再为 `name` 单独建立索引。

#### 5. **索引下推优化（Index Condition Pushdown, ICP）**

- **问题描述**：在联合索引 `(name, age)` 上的复杂查询，如何减少不必要的回表操作？
- **概念**：MySQL 5.6 引入的 **索引下推优化** 允许在索引遍历过程中，对索引中包含的字段先做过滤判断，避免回表。只有符合条件的记录才会回表，减少回表次数。
- **示例**：
    - SQL：`select * from tuser where name like '张%' and age = 10 and ismale = 1`
    - 在没有索引下推的情况下，会对所有 `name like '张%'` 的记录逐条回表。
    - 在有索引下推的情况下，InnoDB 在索引内部先过滤 `age = 10`，减少回表次数。

#### 6. **总结与小结**

- **关键概念**：
    - 回表：通过主键访问主表获取完整数据的过程。
    - 覆盖索引：索引包含查询所需的全部字段，避免回表。
    - 最左前缀原则：联合索引从最左侧字段开始使用，提升索引复用效率。
    - 索引下推：通过索引字段的提前过滤，减少回表次数。
- **数据库设计原则**：在满足业务需求的前提下，尽量减少资源消耗。根据高频查询需求，合理设计索引顺序与覆盖索引，优化查询效率。
