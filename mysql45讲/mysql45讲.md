# 04 深入浅出索引 上
### 一、索引的常见模型

1. **哈希表**

    - 结构：键 - 值存储
    - 优点：快速等值查询
    - 缺点：范围查询效率低
    - 适用场景：等值查询
2. **有序数组**
    - 结构：按顺序存储，支持二分查找
    - 优点：高效等值和范围查询，时间复杂度 $O(\log(N))$
    - 缺点：插入操作开销大
    - 适用场景：静态存储（不常修改的数据）
3. **二叉搜索树**
    - 特点：左子树小于父节点，右子树大于父节点
    - 优点：查询和更新时间复杂度 $O(\log(N))$
    - 缺点：树高对查询效率影响，磁盘访问性能差
    - 发展为多叉树（N叉树）以减少磁盘访问

### 二、InnoDB的索引模型

1. **B+树索引**
    
    - 组织方式：主键索引（聚簇索引）与非主键索引（二级索引）
    - 主键索引：叶子节点存储整行数据
    - 非主键索引：叶子节点存储主键值
    - 查询过程：主键索引直接查找，非主键索引需要“回表”
2. **索引维护**
    
    - 插入数据时的页分裂和合并
    - 性能影响与空间利用率
    - 自增主键的优点：减少插入时的移动与分裂

### 三、索引选择原则

- 自增主键 vs 业务字段主键
    - 存储空间与性能的权衡
    - 适用场景的分析

### 四、重建索引

- 主键索引与普通索引重建的注意事项
- 性能影响与最佳实践

### 小结

- 综述B+树索引的性能优越性
- 建议使用自增主键以优化空间和性能
- 留下思考问题，鼓励读者参与讨论

Mysql b+树
![[Pasted image 20240926001539.png]]

# 为什么 innodb 选择 b加树 作为索引结构？
InnoDB存储引擎选择B+树索引的原因主要体现在以下几个方面：

### 1. **搜索效率高**

- **层级较少**：**由于B+树的非叶子节点只存储指针，能够承载更多的子节点，从而使树的高度更低。这意味着在进行查找时，所需的比较次数减少，访问速度更快。**
### 3. **范围查询和排序**
- **叶子节点双向链表**：B+树的叶子节点形成双向链表，这使得范围查询和排序操作更加高效。用户可以在叶子节点中快速遍历数据，适合执行如 `BETWEEN` 和 `ORDER BY` 的查询。
### 4. **更好的空间利用**
- **数据分离**：B+树的叶子节点存储实际数据，而非叶子节点只存储指针，这样可以更有效地利用存储空间。同时，叶子节点的设计使得它们可以有效地填充，从而减少空间浪费。
### 5. **插入和删除操作**

- **平衡性维护**：B+树能够在插入和删除操作后自我平衡，保持树的结构稳定性。这保证了操作的时间复杂度在 `O(log n)` 范围内，适合高并发的数据库环境。

### 6. **对比其他索引结构**

- **与哈希索引的对比**：哈希索引只支持等值匹配，不支持范围查询和排序操作，这限制了其使用场景。而B+树能够处理更多类型的查询，提供更大的灵活性。
# 索引类型
![[Pasted image 20240926002639.png|500]]
![[Pasted image 20240926002812.png|500]]
# 04深入浅出索引 下
### 索引深入浅出（下）——大纲和要点总结

#### 1. **基本索引操作过程**

- **问题描述**：在 `select * from T where k between 3 and 5` 查询中，需要几次树的搜索操作？涉及到几次回表操作？
- **示例分析**：
    - 通过 **k 索引树** 定位到 k=3 和 k=5 的记录。
    - 通过主键 ID 进行回表，获取对应的记录数据。
    - 总共涉及 **3 次索引读取** 和 **2 次回表**。

#### 2. **回表与覆盖索引**

- **回表**：在二级索引（非聚簇索引）中，如果需要的字段不在索引中，必须通过主键再次访问主表获取完整数据，这个过程称为 **回表**。
- **覆盖索引**：如果查询所需的字段全部包含在索引中，则可以避免回表直接返回数据。这种情况称为 **覆盖索引**。
    - 优点：减少回表次数，提升查询性能。
    - 示例：`select ID from T where k between 3 and 5` 只需要读取 k 索引上的 ID，不需要回表。

#### 3. **联合索引与冗余索引**

- **问题描述**：是否有必要为市民信息表创建 `(身份证号, 姓名)` 的联合索引？
- **解答**：如果有高频查询是基于 **身份证号查询姓名** 的场景，联合索引有助于覆盖查询，减少回表。然而，建立冗余索引的代价较高，需要根据业务需求权衡是否增加冗余索引。

#### 4. **最左前缀原则**

- **概念**：在联合索引中，B+树索引可以通过 **最左前缀** 来加速检索，即可以使用索引的最左边 N 个字段或最左 M 个字符进行快速定位。
- **示例分析**：
    - 联合索引 `(name, age)` 可以用于 `where name = '张三'` 的查询，也可以用于 `where name like '张%'` 的范围查询。
    - **字段顺序的设计**：如果一个联合索引能够通过调整字段顺序减少索引维护成本，那么应优先考虑这一调整。比如 `(name, age)` 索引可以加速基于 `name` 的查询，不必再为 `name` 单独建立索引。

#### 5. **索引下推优化（Index Condition Pushdown, ICP）**

- **问题描述**：在联合索引 `(name, age)` 上的复杂查询，如何减少不必要的回表操作？
- **概念**：MySQL 5.6 引入的 **索引下推优化** 允许在索引遍历过程中，对索引中包含的字段先做过滤判断，避免回表。只有符合条件的记录才会回表，减少回表次数。
- **示例**：
    - SQL：`select * from tuser where name like '张%' and age = 10 and ismale = 1`
    - 在没有索引下推的情况下，会对所有 `name like '张%'` 的记录逐条回表。
    - 在有索引下推的情况下，InnoDB 在索引内部先过滤 `age = 10`，减少回表次数。

#### 6. **总结与小结**

- **关键概念**：
    - 回表：通过主键访问主表获取完整数据的过程。
    - 覆盖索引：索引包含查询所需的全部字段，避免回表。
    - 最左前缀原则：联合索引从最左侧字段开始使用，提升索引复用效率。
    - 索引下推：通过索引字段的提前过滤，减少回表次数。
- **数据库设计原则**：在满足业务需求的前提下，尽量减少资源消耗。根据高频查询需求，合理设计索引顺序与覆盖索引，优化查询效率。


# 总结大纲和要点: 全局锁和表锁 —— 给表加个字段怎么有这么多阻碍？
---
#### 二、全局锁
- **定义**: 对整个数据库实例加锁。
- **加锁方法**: `FLUSH TABLES WITH READ LOCK (FTWRL)`
- **主要应用场景**: 全库逻辑备份，确保备份期间数据库处于只读状态。
- **风险与限制**:
    - 主库备份时，更新操作被阻塞，可能导致业务停摆。
    - 从库备份时，binlog同步被阻塞，导致主从延迟。
- **替代方法**: 使用 `mysqldump` 的 `--single-transaction` 参数，适用于支持事务的引擎（如 InnoDB）。
- **为何不使用 `SET GLOBAL READONLY=true`**:
    1. 可能影响系统中其他依赖 `readonly` 状态的逻辑。
    2. 异常断开时，全局锁会自动释放，而 `readonly` 状态则可能长期保持，增加风险。
#### 三、表级锁
- **分类**: 表锁和元数据锁（MDL）。
    
    **1. 表锁**
    
    - **语法**: `LOCK TABLES ... READ/WRITE`，`UNLOCK TABLES` 释放锁。
    - **作用**: 限制其他线程对指定表的读写操作，同时限制当前线程的操作范围。
    - **使用场景**: 主要用于不支持行锁的存储引擎（如 MyISAM）。
    - **注意事项**: 对 InnoDB 引擎不推荐使用，因锁粒度过大影响并发性能。
    
    **2. 元数据锁（MDL）**
    
    - **定义**: 自动加锁，确保读写操作的正确性。
    - **作用**:
        - 对表的增删改查操作加 MDL 读锁。
        - 对表结构变更操作加 MDL 写锁。
    - **锁的互斥关系**:
        - 读锁之间不互斥，可并行执行。
        - 读写锁、写锁之间互斥，确保表结构变更的安全性。
    - **实例分析**:
        - 在进行表结构变更时，如添加字段，即使是小表，也可能因 MDL 锁导致整个表的查询和更新被阻塞，进而可能导致数据库挂起。
    - **安全操作建议**:
        - 避免长事务占用 MDL 锁，必要时暂停或终止长事务。
        - 对于高频访问的热点表，使用 `ALTER TABLE ... NOWAIT/WAIT n` 语法（MariaDB 和 AliSQL 支持）设定等待时间，避免长时间阻塞。
#### 四、小结
- **全局锁**:
    - 适用于逻辑备份，但需谨慎使用，优先选择 `--single-transaction` 参数的备份方法。
    - 避免使用 `SET GLOBAL READONLY=true`，推荐使用 `FTWRL`。
- **表级锁**:
    - 仅在不支持行锁的存储引擎中使用。
    - 避免在高并发场景下使用 `LOCK TABLES`，优先依赖 InnoDB 的行锁机制。
    - 注意 MDL 锁的影响，确保表结构变更不会影响线上查询和更新。
#### 五、互动与思考题

- **思考题**:
    - 备库使用 `--single-transaction` 备份时，主库进行 DDL 操作，备库会出现何种现象？
- **评论区精选**:
    - 用户提问和作者回复，深入讨论了 MDL 锁的行为及其在不同场景下的表现。

---

### 关键要点

1. **锁的分类**: MySQL中的锁分为全局锁、表级锁和行锁，本文重点讨论全局锁和表级锁。
2. **全局锁的使用与风险**:
    - 通过 `FTWRL` 实现全库只读，适用于逻辑备份。
    - 备份期间可能导致业务停摆或主从延迟。
    - 推荐使用支持事务的 `--single-transaction` 备份方法。
3. **表级锁的类型与应用**:
    - **表锁**: 通过 `LOCK TABLES` 控制，适用于不支持行锁的存储引擎，但对 InnoDB 不推荐。
    - **MDL**: 自动管理，确保表操作的一致性，需注意其在高并发或表结构变更时的影响。
4. **安全操作建议**:
    - 尽量使用行锁机制（如 InnoDB）以提高并发性能。
    - 在进行 DDL 操作时，使用 `NOWAIT/WAIT n` 语法避免长时间阻塞。
    - 监控和管理事务，防止长事务占用 MDL 锁导致系统挂起。
5. **实际案例分析**:
    - 通过具体示例说明全局锁和表级锁在备份和 DDL 操作中的表现及潜在问题。

---

### 建议阅读与复习

- **下一篇文章**: 行锁的详细介绍。
- **相关知识**: 事务隔离级别，特别是可重复读隔离级别下的一致性视图。
- **工具使用**: 熟悉 `mysqldump` 的不同参数及其适用场景。