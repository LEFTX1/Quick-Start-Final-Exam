- [[#一、索引的常见模型|一、索引的常见模型]]
- [[#二、InnoDB的索引模型|二、InnoDB的索引模型]]
- [[#三、索引选择原则|三、索引选择原则]]
- [[#四、重建索引|四、重建索引]]
- [[#小结|小结]]
- [[#1. **搜索效率高**|1. **搜索效率高**]]
- [[#3. **范围查询和排序**|3. **范围查询和排序**]]
- [[#4. **更好的空间利用**|4. **更好的空间利用**]]
- [[#5. **插入和删除操作**|5. **插入和删除操作**]]
- [[#6. **对比其他索引结构**|6. **对比其他索引结构**]]
- [[#索引深入浅出（下）——大纲和要点总结|索引深入浅出（下）——大纲和要点总结]]
	- [[#索引深入浅出（下）——大纲和要点总结#1. **基本索引操作过程**|1. **基本索引操作过程**]]
	- [[#索引深入浅出（下）——大纲和要点总结#2. **回表与覆盖索引**|2. **回表与覆盖索引**]]
	- [[#索引深入浅出（下）——大纲和要点总结#3. **联合索引与冗余索引**|3. **联合索引与冗余索引**]]
	- [[#索引深入浅出（下）——大纲和要点总结#4. **最左前缀原则**|4. **最左前缀原则**]]
	- [[#索引深入浅出（下）——大纲和要点总结#5. **索引下推优化（Index Condition Pushdown, ICP）**|5. **索引下推优化（Index Condition Pushdown, ICP）**]]
	- [[#索引深入浅出（下）——大纲和要点总结#6. **总结与小结**|6. **总结与小结**]]
	- [[#索引深入浅出（下）——大纲和要点总结#二、全局锁|二、全局锁]]
	- [[#索引深入浅出（下）——大纲和要点总结#三、表级锁|三、表级锁]]
	- [[#索引深入浅出（下）——大纲和要点总结#四、小结|四、小结]]
	- [[#索引深入浅出（下）——大纲和要点总结#五、互动与思考题|五、互动与思考题]]
- [[#关键要点|关键要点]]
- [[#建议阅读与复习|建议阅读与复习]]
	- [[#建议阅读与复习#1. **引言**|1. **引言**]]
	- [[#建议阅读与复习#2. **InnoDB 行锁简介**|2. **InnoDB 行锁简介**]]
	- [[#建议阅读与复习#3. **两阶段锁协议**|3. **两阶段锁协议**]]
	- [[#建议阅读与复习#4. **死锁和死锁检测**|4. **死锁和死锁检测**]]
	- [[#建议阅读与复习#5. **如何减少死锁和优化性能？**|5. **如何减少死锁和优化性能？**]]
	- [[#建议阅读与复习#6. **总结**|6. **总结**]]
	- [[#建议阅读与复习#7. **问题留给读者**|7. **问题留给读者**]]
- [[#1. **直接执行 `delete from T limit 10000;`**|1. **直接执行 `delete from T limit 10000;`**]]
- [[#2. **循环执行 20 次 `delete from T limit 500;`**|2. **循环执行 20 次 `delete from T limit 500;`**]]
- [[#3. **在 20 个连接中同时执行 `delete from T limit 500;`**|3. **在 20 个连接中同时执行 `delete from T limit 500;`**]]
- [[#答案：|答案：]]
- [[#1. 插入数据优化|1. 插入数据优化]]
- [[#1. 插入数据优化#一次性插入多条记录|一次性插入多条记录]]
- [[#1. 插入数据优化#大批量数据插入优化|大批量数据插入优化]]
- [[#2. 主键优化|2. 主键优化]]
- [[#3. 排序优化|3. 排序优化]]
- [[#3. 排序优化#MySQL 两种排序方式|MySQL 两种排序方式]]
- [[#3. 排序优化#排序优化原则|排序优化原则]]
- [[#4. Group By 优化|4. Group By 优化]]
- [[#5. LIMIT 分页查询优化|5. LIMIT 分页查询优化]]
- [[#6. COUNT 优化|6. COUNT 优化]]
- [[#7. UPDATE 操作优化|7. UPDATE 操作优化]]
- [[#总结与提升|总结与提升]]






# 04 深入浅出索引 上
### 一、索引的常见模型

1. **哈希表**

    - 结构：键 - 值存储
    - 优点：快速等值查询
    - 缺点：范围查询效率低
    - 适用场景：等值查询
2. **有序数组**
    - 结构：按顺序存储，支持二分查找
    - 优点：高效等值和范围查询，时间复杂度 $O(\log(N))$
    - 缺点：插入操作开销大
    - 适用场景：静态存储（不常修改的数据）
3. **二叉搜索树**
    - 特点：左子树小于父节点，右子树大于父节点
    - 优点：查询和更新时间复杂度 $O(\log(N))$
    - 缺点：树高对查询效率影响，磁盘访问性能差
    - 发展为多叉树（N叉树）以减少磁盘访问

### 二、InnoDB的索引模型

1. **B+树索引**
    
    - 组织方式：主键索引（聚簇索引）与非主键索引（二级索引）
    - 主键索引：叶子节点存储整行数据
    - 非主键索引：叶子节点存储主键值
    - 查询过程：主键索引直接查找，非主键索引需要“回表”
2. **索引维护**
    
    - 插入数据时的页分裂和合并
    - 性能影响与空间利用率
    - 自增主键的优点：减少插入时的移动与分裂

### 三、索引选择原则

- 自增主键 vs 业务字段主键
    - 存储空间与性能的权衡
    - 适用场景的分析

### 四、重建索引

- 主键索引与普通索引重建的注意事项
- 性能影响与最佳实践

### 小结

- 综述B+树索引的性能优越性
- 建议使用自增主键以优化空间和性能
- 留下思考问题，鼓励读者参与讨论

Mysql b+树
![[Pasted image 20240926001539.png]]

# 为什么 innodb 选择 b加树 作为索引结构？
InnoDB存储引擎选择B+树索引的原因主要体现在以下几个方面：

### 1. **搜索效率高**

- **层级较少**：**由于B+树的非叶子节点只存储指针，能够承载更多的子节点，从而使树的高度更低。这意味着在进行查找时，所需的比较次数减少，访问速度更快。**
### 3. **范围查询和排序**
- **叶子节点双向链表**：B+树的叶子节点形成双向链表，这使得范围查询和排序操作更加高效。用户可以在叶子节点中快速遍历数据，适合执行如 `BETWEEN` 和 `ORDER BY` 的查询。
### 4. **更好的空间利用**
- **数据分离**：B+树的叶子节点存储实际数据，而非叶子节点只存储指针，这样可以更有效地利用存储空间。同时，叶子节点的设计使得它们可以有效地填充，从而减少空间浪费。
### 5. **插入和删除操作**

- **平衡性维护**：B+树能够在插入和删除操作后自我平衡，保持树的结构稳定性。这保证了操作的时间复杂度在 `O(log n)` 范围内，适合高并发的数据库环境。

### 6. **对比其他索引结构**

- **与哈希索引的对比**：哈希索引只支持等值匹配，不支持范围查询和排序操作，这限制了其使用场景。而B+树能够处理更多类型的查询，提供更大的灵活性。
# 索引类型
![[Pasted image 20240926002639.png|500]]
![[Pasted image 20240926002812.png|500]]
# 05深入浅出索引 下
### 索引深入浅出（下）——大纲和要点总结

#### 1. **基本索引操作过程**

- **问题描述**：在 `select * from T where k between 3 and 5` 查询中，需要几次树的搜索操作？涉及到几次回表操作？
- **示例分析**：
    - 通过 **k 索引树** 定位到 k=3 和 k=5 的记录。
    - 通过主键 ID 进行回表，获取对应的记录数据。
    - 总共涉及 **3 次索引读取** 和 **2 次回表**。

#### 2. **回表与覆盖索引**

- **回表**：在二级索引（非聚簇索引）中，如果需要的字段不在索引中，必须通过主键再次访问主表获取完整数据，这个过程称为 **回表**。
- **覆盖索引**：如果查询所需的字段全部包含在索引中，则可以避免回表直接返回数据。这种情况称为 **覆盖索引**。
    - 优点：减少回表次数，提升查询性能。
    - 示例：`select ID from T where k between 3 and 5` 只需要读取 k 索引上的 ID，不需要回表。

#### 3. **联合索引与冗余索引**

- **问题描述**：是否有必要为市民信息表创建 `(身份证号, 姓名)` 的联合索引？
- **解答**：如果有高频查询是基于 **身份证号查询姓名** 的场景，联合索引有助于覆盖查询，减少回表。然而，建立冗余索引的代价较高，需要根据业务需求权衡是否增加冗余索引。

#### 4. **最左前缀原则**

- **概念**：在联合索引中，B+树索引可以通过 **最左前缀** 来加速检索，即可以使用索引的最左边 N 个字段或最左 M 个字符进行快速定位。
- **示例分析**：
    - 联合索引 `(name, age)` 可以用于 `where name = '张三'` 的查询，也可以用于 `where name like '张%'` 的范围查询。
    - **字段顺序的设计**：如果一个联合索引能够通过调整字段顺序减少索引维护成本，那么应优先考虑这一调整。比如 `(name, age)` 索引可以加速基于 `name` 的查询，不必再为 `name` 单独建立索引。

#### 5. **索引下推优化（Index Condition Pushdown, ICP）**

- **问题描述**：在联合索引 `(name, age)` 上的复杂查询，如何减少不必要的回表操作？
- **概念**：MySQL 5.6 引入的 **索引下推优化** 允许在索引遍历过程中，对索引中包含的字段先做过滤判断，避免回表。只有符合条件的记录才会回表，减少回表次数。
- **示例**：
    - SQL：`select * from tuser where name like '张%' and age = 10 and ismale = 1`
    - 在没有索引下推的情况下，会对所有 `name like '张%'` 的记录逐条回表。
    - 在有索引下推的情况下，InnoDB 在索引内部先过滤 `age = 10`，减少回表次数。

#### 6. **总结与小结**

- **关键概念**：
    - 回表：通过主键访问主表获取完整数据的过程。
    - 覆盖索引：索引包含查询所需的全部字段，避免回表。
    - 最左前缀原则：联合索引从最左侧字段开始使用，提升索引复用效率。
    - 索引下推：通过索引字段的提前过滤，减少回表次数。
- **数据库设计原则**：在满足业务需求的前提下，尽量减少资源消耗。根据高频查询需求，合理设计索引顺序与覆盖索引，优化查询效率。



# 06总结大纲和要点: 全局锁和表锁 —— 给表加个字段怎么有这么多阻碍？
---
#### 二、全局锁
- **定义**: 对整个数据库实例加锁。
- **加锁方法**: `FLUSH TABLES WITH READ LOCK (FTWRL)`
- **主要应用场景**: 全库逻辑备份，确保备份期间数据库处于只读状态。
- **风险与限制**:
    - 主库备份时，更新操作被阻塞，可能导致业务停摆。
    - 从库备份时，binlog同步被阻塞，导致主从延迟。
- **替代方法**: 使用 `mysqldump` 的 `--single-transaction` 参数，适用于支持事务的引擎（如 InnoDB）。
- **为何不使用 `SET GLOBAL READONLY=true`**:
    1. 可能影响系统中其他依赖 `readonly` 状态的逻辑。
    2. 异常断开时，全局锁会自动释放，而 `readonly` 状态则可能长期保持，增加风险。
#### 三、表级锁
- **分类**: 表锁和元数据锁（MDL）。
    
    **1. 表锁**
    
    - **语法**: `LOCK TABLES ... READ/WRITE`，`UNLOCK TABLES` 释放锁。
    - **作用**: 限制其他线程对指定表的读写操作，同时限制当前线程的操作范围。
    - **使用场景**: 主要用于不支持行锁的存储引擎（如 MyISAM）。
    - **注意事项**: 对 InnoDB 引擎不推荐使用，因锁粒度过大影响并发性能。
    
    **2. 元数据锁（MDL）**
    
    - **定义**: 自动加锁，确保读写操作的正确性。
    - **作用**:
        - 对表的增删改查操作加 MDL 读锁。
        - 对表结构变更操作加 MDL 写锁。
    - **锁的互斥关系**:
        - 读锁之间不互斥，可并行执行。
        - 读写锁、写锁之间互斥，确保表结构变更的安全性。
    - **实例分析**:
        - 在进行表结构变更时，如添加字段，即使是小表，也可能因 MDL 锁导致整个表的查询和更新被阻塞，进而可能导致数据库挂起。
    - **安全操作建议**:
        - 避免长事务占用 MDL 锁，必要时暂停或终止长事务。
        - 对于高频访问的热点表，使用 `ALTER TABLE ... NOWAIT/WAIT n` 语法（MariaDB 和 AliSQL 支持）设定等待时间，避免长时间阻塞。
#### 四、小结
- **全局锁**:
    - 适用于逻辑备份，但需谨慎使用，优先选择 `--single-transaction` 参数的备份方法。
    - 避免使用 `SET GLOBAL READONLY=true`，推荐使用 `FTWRL`。
- **表级锁**:
    - 仅在不支持行锁的存储引擎中使用。
    - 避免在高并发场景下使用 `LOCK TABLES`，优先依赖 InnoDB 的行锁机制。
    - 注意 MDL 锁的影响，确保表结构变更不会影响线上查询和更新。
#### 五、互动与思考题

- **思考题**:
    - 备库使用 `--single-transaction` 备份时，主库进行 DDL 操作，备库会出现何种现象？
- **评论区精选**:
    - 用户提问和作者回复，深入讨论了 MDL 锁的行为及其在不同场景下的表现。

---

### 关键要点

1. **锁的分类**: MySQL中的锁分为全局锁、表级锁和行锁，本文重点讨论全局锁和表级锁。
2. **全局锁的使用与风险**:
    - 通过 `FTWRL` 实现全库只读，适用于逻辑备份。
    - 备份期间可能导致业务停摆或主从延迟。
    - 推荐使用支持事务的 `--single-transaction` 备份方法。
3. **表级锁的类型与应用**:
    - **表锁**: 通过 `LOCK TABLES` 控制，适用于不支持行锁的存储引擎，但对 InnoDB 不推荐。
    - **MDL**: 自动管理，确保表操作的一致性，需注意其在高并发或表结构变更时的影响。
4. **安全操作建议**:
    - 尽量使用行锁机制（如 InnoDB）以提高并发性能。
    - 在进行 DDL 操作时，使用 `NOWAIT/WAIT n` 语法避免长时间阻塞。
    - 监控和管理事务，防止长事务占用 MDL 锁导致系统挂起。
5. **实际案例分析**:
    - 通过具体示例说明全局锁和表级锁在备份和 DDL 操作中的表现及潜在问题。

---

### 建议阅读与复习

- **下一篇文章**: 行锁的详细介绍。
- **相关知识**: 事务隔离级别，特别是可重复读隔离级别下的一致性视图。
- **工具使用**: 熟悉 `mysqldump` 的不同参数及其适用场景。


# **07 | 行锁功过：怎么减少行锁对性能的影响？**

#### 1. **引言**

- 行锁是 MySQL 引擎层实现的锁机制，InnoDB 支持行锁，MyISAM 只支持表锁。
- 行锁有助于提高并发处理能力，而表锁会影响业务并发度。

#### 2. **InnoDB 行锁简介**

- InnoDB 支持行级锁，允许并发事务访问不同的行。
- 如果多个事务更新同一行，后来的事务会被阻塞，直到前一个事务提交或回滚。

#### 3. **两阶段锁协议**

- **加锁时机**：行锁在操作需要时才加锁。
- **锁释放时机**：行锁在事务结束（commit 或 rollback）时才释放，而不是操作结束时释放。
- **优化策略**：如果事务中涉及多个行的更新，应该将可能引起锁冲突的更新操作尽量放到事务的后面，减少锁的持有时间，从而提升并发度。

**示例**：在线电影票交易业务

- 操作涉及更新顾客账户余额、影院账户余额、插入交易日志。
- 为了减少锁冲突，将对影院账户余额的更新放到最后进行（最可能冲突的行锁操作尽量后置）。

#### 4. **死锁和死锁检测**

- **死锁定义**：当多个事务互相等待对方释放资源时，系统进入死锁状态。
    
- **两种死锁解决策略**：
    
    1. **超时等待**：通过设置 `innodb_lock_wait_timeout` 参数来定义超时回滚时间（默认50秒）。
    2. **死锁检测**：启用死锁检测，检测到死锁时回滚其中一个事务，以避免无限等待。
- **死锁检测的额外负担**：死锁检测的复杂度是 O(n)，在高并发场景下（如多个事务同时更新同一行数据）会消耗大量 CPU 资源，导致性能瓶颈。
    

#### 5. **如何减少死锁和优化性能？**

1. **关闭死锁检测（风险高）**：如果确保业务不会产生死锁，可以临时关闭死锁检测（`innodb_deadlock_detect` 设为 OFF）。但如果出现死锁，会导致超时回滚，增加业务风险。
    
2. **控制并发度**：减少访问相同数据行的并发事务数。可以通过客户端或中间件层面控制，但在客户端并发数较多时，仍可能导致服务器端并发过高。
    
3. **逻辑分片减少锁冲突**：将热点数据（如影院账户余额）分成多条记录，更新时随机选择一条记录更新，减少并发事务访问同一行的概率，从而降低锁竞争和死锁检测的开销。
    
    - 示例：影院账户余额分为10条记录，随机更新其中一条，减少并发冲突的概率。

#### 6. **总结**

- 行锁能够提升并发度，但可能导致锁冲突和死锁问题。
- 两阶段锁协议下，操作的顺序设计很重要，应该将冲突可能性大的锁操作尽量后置，减少锁的持有时间。
- 死锁检测是应对死锁的有效机制，但在高并发下可能带来性能开销，优化措施包括关闭检测、控制并发、使用逻辑分片。

#### 7. **问题留给读者**

- 如果需要删除表中的前 10000 行数据，选择以下哪种方式？为什么？
    1. 直接执行 `delete from T limit 10000;`
    2. 循环执行20次 `delete from T limit 500;`
    3. 在20个连接中同时执行 `delete from T limit 500;`


对于最后的问题，删除表中前 10,000 行数据的三种方式，每种方式的优缺点如下：

### 1. **直接执行 `delete from T limit 10000;`**

- **优点**：单次操作，语句简单，不需要额外的控制逻辑。
- **缺点**：一次性删除大量数据，可能导致锁表时间过长，特别是当表非常大时。大批量删除还会消耗大量资源（如 I/O 和内存），影响其他并发操作。

### 2. **循环执行 20 次 `delete from T limit 500;`**

- **优点**：通过多次删除操作，将大批量删除分散为小批量删除，减少了单次操作的负载和锁定时间，降低了对其他并发事务的影响。
- **缺点**：需要在代码层面实现循环逻辑，数据库执行20次操作，操作次数较多，增加了一定的开销。

### 3. **在 20 个连接中同时执行 `delete from T limit 500;`**

- **优点**：通过并行化操作，删除数据的速度会更快，操作在多个连接中同时进行，理论上可以更好地利用系统资源，降低整体删除时间。
- **缺点**：并发连接同时删除数据，可能会产生**行锁冲突**，导致部分操作被阻塞或回滚。如果不处理好并发事务的协调，可能带来额外的死锁或性能问题。此外，多连接并发也会增加系统的负载，可能对其他操作产生影响。

### 答案：

**推荐第二种方法**——**循环执行 20 次 `delete from T limit 500;`**。

这是因为：

- 小批量删除能够有效减少锁定时间，降低单次操作对系统性能的影响。
- 同时，它不会像并发删除那样容易造成行锁冲突或死锁问题。
- 比起一次性删除大量数据，它更容易被 MySQL 处理，避免造成 I/O 和内存的过载。

尽管并行删除在某些特定场景下可能更快，但风险更大，因此第二种方式在绝大多数场景下是更稳定、合理的选择。


# SQL 优化笔记

## 1. 插入数据优化

### 一次性插入多条记录
- **批量插入**: 使用批量插入语法 (`INSERT INTO ... VALUES ...`) 而非逐条插入，减少数据库交互和事务提交，提高性能。
- **手动控制事务**: 大批量插入时，可以手动控制事务，避免每条记录都单独提交事务，提高效率。
- **主键顺序插入**: 使用顺序插入（如 `AUTO_INCREMENT` 自增主键）比乱序插入性能更好，避免索引页分裂。

### 大批量数据插入优化
- **LOAD DATA INFILE**: 使用 `LOAD DATA INFILE` 来进行大规模数据的快速插入。适用于几百万甚至更多记录。
  - 客户端启用 `--local-infile` 参数。
  - 服务端设置 `local_infile = 1`。
  - 语法:
    ```sql
    LOAD DATA LOCAL INFILE '/path/to/file' INTO TABLE table_name 
    FIELDS TERMINATED BY ',' LINES TERMINATED BY '\n';
    ```

## 2. 主键优化
- **顺序插入**: 使用 `AUTO_INCREMENT` 自增主键，避免使用 UUID 或自然主键，减少页分裂。
- **降低主键长度**: 主键越短，二级索引占用的空间越少，性能更高。
- **避免修改主键**: 修改主键会导致索引重建，影响性能。

## 3. 排序优化

### MySQL 两种排序方式
- **Using Filesort**: 非索引字段排序会使用 `filesort`，需要将数据放入 `sort_buffer` 排序，性能较低。
- **Using Index**: 通过已有索引直接返回有序结果，效率最高。

### 排序优化原则
- **基于排序字段建立索引**: 对排序字段建立合适的索引，尤其是多字段排序时遵循最左前缀法则。
- **覆盖索引**: 使用覆盖索引，避免回表查询，提升性能。
- **多字段排序时注意索引顺序**: 针对多字段排序（如一个升序一个降序）时，创建联合索引时需注意顺序。
- **增大排序缓冲区**: 对大数据量排序，增大 `sort_buffer_size`（默认 256k）提升性能。

## 4. Group By 优化
- **索引优化**: `GROUP BY` 操作可以通过索引提升效率，同样需遵循最左前缀原则。
- **减少 `GROUP BY` 使用**: 应用层处理分组有时更高效。

## 5. LIMIT 分页查询优化
- **问题**: 数据量大时，`LIMIT` 的偏移量越大，查询越慢。
- **优化思路**: 
  - 使用 **覆盖索引** 提升查询性能，避免读取不必要的行。
  - 使用 **子查询** 优化:
    ```sql
    SELECT * FROM tb_sku t, 
    (SELECT id FROM tb_sku ORDER BY id LIMIT 2000000,10) a 
    WHERE t.id = a.id;
    ```

## 6. COUNT 优化
- **性能对比**: 使用 `COUNT(*)` 性能最佳，推荐使用。不同 COUNT 操作的性能排序：
  - `COUNT(字段)` < `COUNT(主键 id)` < `COUNT(1)` ≈ `COUNT(*)`
  - 注意: `COUNT(NULL)` 不会计数。
！！- `COUNT(*)` 是 MySQL 中性能最优的行数统计方法，推荐优先使用。
- `COUNT(字段)` 会过滤掉 `NULL`，并因此增加计算负担，性能相对较差。
- `COUNT(1)` 和 `COUNT(*)` 基本上是等效的，性能相同，具体情况视数据库优化器的行为而定。
- 避免使用 `COUNT(NULL)`，因为它总是返回 `0`。
## 7. UPDATE 操作优化
- **行锁与表锁**: InnoDB 的行锁基于索引，若条件字段没有索引，会导致行锁升级为表锁，影响性能。
  - **索引避免表锁**: 确保 `UPDATE` 条件字段有索引，避免表锁。例如：
    ```sql
    -- 针对主键操作，加行锁
    UPDATE course SET name = 'javaEE' WHERE id = 1;
    -- 针对非索引字段操作，可能加表锁
    UPDATE course SET name = 'SpringBoot' WHERE name = 'PHP';
    ```

## 总结与提升
- **索引设计与使用**: 针对查询频繁的字段建立索引，遵循最左前缀法则，使用覆盖索引减少回表查询。
- **批量操作**: 批量插入、更新或删除操作更高效，手动控制事务提升性能。
- **分页查询优化**: 大数据量情况下，优化 `LIMIT` 查询，避免大量偏移。
- **参数调优**: 根据业务需求适当调整数据库参数，如 `sort_buffer_size` 和 `innodb_buffer_pool_size`。

